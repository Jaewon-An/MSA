7단계: discovery 서비스 배포 파이프라인 구성 (Eureka Server) discovery 서비스는 Service Discovery (Eureka Server)로 MSA에서 매우 중요한 역할을 합니다.

7-1. discovery 서비스 확인

```bash
# 1. discovery 디렉토리로 이동
cd /data/svn-workspace/lib-seoul-trunk/discovery
# 2. 파일 구조 확인
ls -la
# 3. 빌드 파일 확인
ls -lh build.gradle pom.xml 2>/dev/null
# 4. Dockerfile 확인
ls -lh Dockerfile* 2>/dev/null
# 5. 포트 확인 (application.yml)
find . -name "application*.yml" -o -name "application*.properties" | xargs grep -i "port" 2>/dev/null | head -5
```

7-2. 필요한 파일 생성 Dockerfile 생성/확인

```bash
cd /data/svn-workspace/lib-seoul-trunk/discovery
# Dockerfile이 없다면 생성
if [ ! -f Dockerfile ]; then
cat > Dockerfile << 'EOF'
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY build/libs/*.jar app.jar
EXPOSE 8761
ENTRYPOINT ["java", "-jar", "app.jar"]
EOF
echo "✅ Dockerfile 생성"
else
echo "✅ Dockerfile 이미 존재"
cat Dockerfile
fi
```

Kubernetes Deployment 파일 생성

```bash
cd /data/svn-workspace/lib-seoul-trunk/discovery
mkdir -p k8s
# dev 환경
cat > k8s/deployment-dev.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: discovery
  namespace: dev
  labels:
    app: discovery
    env: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: discovery
  template:
    metadata:
      labels:
        app: discovery
        env: dev
    spec:
      imagePullSecrets:
      - name: regcred
      containers:
      - name: discovery
        image: 10.10.1.10:5000/discovery:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8761
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "dev"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8761
          initialDelaySeconds: 120
          periodSeconds: 10
          failureThreshold: 5
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8761
          initialDelaySeconds: 90
          periodSeconds: 5
          failureThreshold: 5
---
apiVersion: v1
kind: Service
metadata:
  name: discovery
  namespace: dev
spec:
  selector:
    app: discovery
  ports:
  - protocol: TCP
    port: 8761
    targetPort: 8761
  type: ClusterIP
EOF
# prod 환경
cat > k8s/deployment-prod.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: discovery
  namespace: prod
  labels:
    app: discovery
    env: prod
spec:
  replicas: 2
  selector:
    matchLabels:
      app: discovery
  template:
    metadata:
      labels:
        app: discovery
        env: prod
    spec:
      imagePullSecrets:
      - name: regcred
      containers:
      - name: discovery
        image: 10.10.1.10:5000/discovery:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8761
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8761
          initialDelaySeconds: 120
          periodSeconds: 10
          failureThreshold: 5
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8761
          initialDelaySeconds: 90
          periodSeconds: 5
          failureThreshold: 5
---
apiVersion: v1
kind: Service
metadata:
  name: discovery
  namespace: prod
spec:
  selector:
    app: discovery
  ports:
  - protocol: TCP
    port: 8761
    targetPort: 8761
  type: ClusterIP
EOF
echo "✅ Kubernetes manifest 생성 완료"
```

Jenkinsfile 생성

```bash
cd /data/svn-workspace/lib-seoul-trunk/discovery
cat > Jenkinsfile << 'EOFPIPE'
pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '10.10.1.10:5000'
        SERVICE_NAME = 'discovery'
        DOCKER_IMAGE = "${DOCKER_REGISTRY}/${SERVICE_NAME}"
        BUILD_TAG = "${env.BUILD_NUMBER}"
    }

    parameters {
        choice(
            name: 'DEPLOY_ENV',
            choices: ['dev', 'prod'],
            description: '배포 환경 선택'
        )
    }

    stages {
        stage('Clean Workspace') {
            steps {
                deleteDir()
            }
        }

        stage('SVN Checkout') {
            steps {
                script {
                    def svnInfo = checkout([
                        $class: 'SubversionSCM',
                        locations: [[
                            remote: 'http://10.10.1.3/svn/lib.seoul.go.kr/trunk/discovery',
                            credentialsId: 'svn-credentials',
                            local: '.',
                            depthOption: 'infinity',
                            ignoreExternalsOption: true
                        ]],
                        quietOperation: false,
                        workspaceUpdater: [$class: 'CheckoutUpdater']
                    ])

                    env.SVN_REVISION = svnInfo.SVN_REVISION
                    echo "✅ SVN Checkout 완료 - Revision: ${env.SVN_REVISION}"
                }
            }
        }

        stage('Build Application') {
            steps {
                script {
                    echo "Gradle 빌드 시작..."
                    sh '''
                        chmod +x gradlew
                        ./gradlew clean build -x test
                    '''
                }
            }
        }

        stage('Run Tests') {
            steps {
                sh './gradlew test || true'
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "Docker 이미지 빌드 중..."
                    echo "Revision: ${env.SVN_REVISION}, Build: ${env.BUILD_TAG}"

                    sh """
                        docker build -t ${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG} .
                        docker tag ${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG} ${DOCKER_IMAGE}:latest
                    """
                }
            }
        }

        stage('Push to Registry') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: 'docker-registry-credentials',
                        usernameVariable: 'REGISTRY_USER',
                        passwordVariable: 'REGISTRY_PASS'
                    )]) {
                        sh """
                            echo \$REGISTRY_PASS | docker login ${DOCKER_REGISTRY} -u \$REGISTRY_USER --password-stdin
                            docker push ${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG}
                            docker push ${DOCKER_IMAGE}:latest
                            docker logout ${DOCKER_REGISTRY}
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    withKubeConfig([credentialsId: 'kubeconfig']) {
                        sh """
                            echo "Kubernetes에 배포 중... (${params.DEPLOY_ENV})"
                            echo "Image: ${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG}"

                            if kubectl get deployment ${SERVICE_NAME} -n ${params.DEPLOY_ENV} 2>/dev/null; then
                                echo "기존 배포 업데이트"
                                kubectl set image deployment/${SERVICE_NAME} \
                                    ${SERVICE_NAME}=${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG} \
                                    -n ${params.DEPLOY_ENV}
                            else
                                echo "초기 배포"
                                kubectl apply -f k8s/deployment-${params.DEPLOY_ENV}.yaml

                                kubectl set image deployment/${SERVICE_NAME} \
                                    ${SERVICE_NAME}=${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG} \
                                    -n ${params.DEPLOY_ENV}
                            fi

                            kubectl rollout status deployment/${SERVICE_NAME} \
                                -n ${params.DEPLOY_ENV} --timeout=5m

                            kubectl get pods -n ${params.DEPLOY_ENV} -l app=${SERVICE_NAME}
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo "========================================="
            echo "✅ 배포 성공"
            echo "서비스: ${SERVICE_NAME}"
            echo "환경: ${params.DEPLOY_ENV}"
            echo "이미지: ${DOCKER_IMAGE}:r${env.SVN_REVISION}-b${env.BUILD_TAG}"
            echo "========================================="
        }
        failure {
            echo "❌ 배포 실패"
            script {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh """
                        echo "롤백 실행 중..."
                        kubectl rollout undo deployment/${SERVICE_NAME} \
                            -n ${params.DEPLOY_ENV} || true
                    """
                }
            }
        }
        always {
            sh 'docker logout ${DOCKER_REGISTRY} || true'
        }
    }
}
EOFPIPE
echo "✅ Jenkinsfile 생성 완료"
```

7-3. SVN 커밋

```bash
cd /data/svn-workspace/lib-seoul-trunk/discovery
# 파일 추가
svn add Dockerfile 2>/dev/null || true
svn add k8s 2>/dev/null || true
svn add Jenkinsfile 2>/dev/null || true
# 상태 확인
svn status
# 커밋
svn commit -m "Add Dockerfile, Kubernetes manifests, and Jenkinsfile for discovery service"
```

7-4. Jenkins Pipeline Job 생성 Jenkins 웹:

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "Jenkins: http://$SERVER_IP:8080"
```

1. New Item → discovery-pipeline → Pipeline → OK
2. General:
    - ☑ This project is parameterized
    - Choice Parameter:
        - Name: DEPLOY_ENV
        - Choices: dev, prod
3. Pipeline:
    - Definition: Pipeline script from SCM
    - SCM: Subversion
    - Repository URL: http://10.10.1.3/svn/lib.seoul.go.kr/trunk/discovery
    - Credentials: svn-credentials
    - Script Path: Jenkinsfile
4. Save

7-5. 빌드 실행 Jenkins 웹:

1. discovery-pipeline → Build with Parameters
2. DEPLOY_ENV: dev → Build
3. Console Output 확인

✅ 7단계 확인

```bash
cd /data/svn-workspace/lib-seoul-trunk/discovery
echo "=== 1. 파일 확인 ==="
ls -la Dockerfile Jenkinsfile k8s/
echo -e "\n=== 2. SVN 상태 ==="
svn info | grep -E "URL|Revision"
echo -e "\n=== 3. 배포 후 Pod 확인 ==="
kubectl get pods -n dev | grep discovery
echo -e "\n=== 4. 서비스 확인 ==="
kubectl get svc -n dev | grep discovery
echo -e "\n=== 5. 전체 서비스 현황 ==="
kubectl get all -n dev
```
