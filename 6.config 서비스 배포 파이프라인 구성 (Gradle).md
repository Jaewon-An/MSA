6단계: config 서비스 배포 파이프라인 구성 (Gradle)

6-1. config 서비스 파일 구조 확인

```bash
# 1. config 디렉토리로 이동
cd /data/svn-workspace/lib-seoul-trunk/config
# 2. 파일 구조 확인
ls -la
# 3. 주요 파일 확인
echo "=== Gradle 파일 ==="
ls -lh build.gradle settings.gradle gradlew 2>/dev/null
echo -e "\n=== Docker 파일 ==="
ls -lh Dockerfile* 2>/dev/null
echo -e "\n=== Kubernetes 파일 ==="
ls -lh DockerfileK8s k8s/ 2>/dev/null
find . -name "*.yaml" -o -name "*.yml" | head -10
```

6-2. 기존 Dockerfile 확인

```bash
# Dockerfile 내용 확인
echo "=== 기존 Dockerfile ==="
cat Dockerfile
```

6-3. 기존 Kubernetes 매니페스트 확인

```bash
# DockerfileK8s 파일 확인
echo "=== DockerfileK8s 파일 ==="
cat DockerfileK8s 2>/dev/null
# k8s 디렉토리 확인
echo -e "\n=== k8s 디렉토리 ==="
ls -la k8s/ 2>/dev/null
# YAML 파일들 확인
echo -e "\n=== YAML 파일 목록 ==="
find . -name "*.yaml" -o -name "*.yml"
```

6-4. build.gradle 확인

```bash
# Gradle 설정 확인
echo "=== build.gradle ==="
cat build.gradle | head -30
```

6-5. Kubernetes Deployment 파일 준비기존 파일을 확인하고 필요하면 수정하겠습니다.

```bash
cd /data/svn-workspace/lib-seoul-trunk/config
# k8s 디렉토리 생성 (없다면)
mkdir -p k8s
# 서버 IP 확인
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "Registry: $SERVER_IP:5000"
```

dev 환경 deployment 생성

```bash
cat > k8s/deployment-dev.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config
  namespace: dev
  labels:
    app: config
    env: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: config
  template:
    metadata:
      labels:
        app: config
        env: dev
    spec:
      containers:
      - name: config
        image: $SERVER_IP:5000/config:latest
        ports:
        - containerPort: 8888
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "dev"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8888
          initialDelaySeconds: 60
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8888
          initialDelaySeconds: 30
          periodSeconds: 5
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: config
  namespace: dev
spec:
  selector:
    app: config
  ports:
  - protocol: TCP
    port: 8888
    targetPort: 8888
  type: ClusterIP
EOF
echo "✅ k8s/deployment-dev.yaml 생성 완료"
```

prod 환경 deployment 생성

```bash
cat > k8s/deployment-prod.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config
  namespace: prod
  labels:
    app: config
    env: prod
spec:
  replicas: 2
  selector:
    matchLabels:
      app: config
  template:
    metadata:
      labels:
        app: config
        env: prod
    spec:
      containers:
      - name: config
        image: $SERVER_IP:5000/config:latest
        ports:
        - containerPort: 8888
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8888
          initialDelaySeconds: 60
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8888
          initialDelaySeconds: 30
          periodSeconds: 5
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: config
  namespace: prod
spec:
  selector:
    app: config
  ports:
  - protocol: TCP
    port: 8888
    targetPort: 8888
  type: ClusterIP
EOF
echo "✅ k8s/deployment-prod.yaml 생성 완료"
```

6-6. Jenkinsfile 생성 (Gradle 버전)

```bash
cd /data/svn-workspace/lib-seoul-trunk/config
SERVER_IP=$(hostname -I | awk '{print $1}')
cat > Jenkinsfile << 'EOFPIPE'
pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '${SERVER_IP}:5000'
        SERVICE_NAME = 'config'
        DOCKER_IMAGE = "${DOCKER_REGISTRY}/${SERVICE_NAME}"
    }

    parameters {
        choice(
            name: 'DEPLOY_ENV',
            choices: ['dev', 'prod'],
            description: '배포 환경 선택'
        )
    }

    stages {
        stage('SVN Checkout') {
            steps {
                checkout([
                    $class: 'SubversionSCM',
                    locations: [[
                        remote: 'http://10.10.1.3/svn/lib.seoul.go.kr/trunk/config',
                        credentialsId: 'svn-credentials',
                        local: '.',
                        depthOption: 'infinity',
                        ignoreExternalsOption: true
                    ]],
                    quietOperation: true,
                    workspaceUpdater: [$class: 'UpdateUpdater']
                ])
            }
        }

        stage('Build Application') {
            steps {
                script {
                    echo "Gradle 빌드 시작..."
                    sh '''
                        chmod +x gradlew
                        ./gradlew clean build -x test
                    '''
                }
            }
        }

        stage('Run Tests') {
            steps {
                sh './gradlew test || true'
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def svnRevision = sh(
                        script: 'svn info --show-item revision',
                        returnStdout: true
                    ).trim()

                    echo "Docker 이미지 빌드 중... (Revision: ${svnRevision})"

                    sh """
                        docker build -t ${DOCKER_IMAGE}:r${svnRevision} .
                        docker tag ${DOCKER_IMAGE}:r${svnRevision} ${DOCKER_IMAGE}:latest
                    """
                }
            }
        }

        stage('Push to Registry') {
            steps {
                script {
                    def svnRevision = sh(
                        script: 'svn info --show-item revision',
                        returnStdout: true
                    ).trim()

                    withCredentials([usernamePassword(
                        credentialsId: 'docker-registry-credentials',
                        usernameVariable: 'REGISTRY_USER',
                        passwordVariable: 'REGISTRY_PASS'
                    )]) {
                        sh """
                            echo \$REGISTRY_PASS | docker login ${DOCKER_REGISTRY} -u \$REGISTRY_USER --password-stdin
                            docker push ${DOCKER_IMAGE}:r${svnRevision}
                            docker push ${DOCKER_IMAGE}:latest
                            docker logout ${DOCKER_REGISTRY}
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def svnRevision = sh(
                        script: 'svn info --show-item revision',
                        returnStdout: true
                    ).trim()

                    withKubeConfig([credentialsId: 'kubeconfig']) {
                        sh """
                            echo "Kubernetes에 배포 중... (${params.DEPLOY_ENV})"

                            # 초기 배포인지 확인
                            if kubectl get deployment ${SERVICE_NAME} -n ${params.DEPLOY_ENV} 2>/dev/null; then
                                echo "기존 배포 업데이트"
                                kubectl set image deployment/${SERVICE_NAME} \
                                    ${SERVICE_NAME}=${DOCKER_IMAGE}:r${svnRevision} \
                                    -n ${params.DEPLOY_ENV}
                            else
                                echo "초기 배포"
                                kubectl apply -f k8s/deployment-${params.DEPLOY_ENV}.yaml
                            fi

                            # 롤아웃 상태 확인
                            kubectl rollout status deployment/${SERVICE_NAME} \
                                -n ${params.DEPLOY_ENV} --timeout=5m
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo "✅ 배포 성공: ${SERVICE_NAME} to ${params.DEPLOY_ENV}"
        }
        failure {
            echo "❌ 배포 실패"
            script {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh """
                        echo "롤백 실행 중..."
                        kubectl rollout undo deployment/${SERVICE_NAME} \
                            -n ${params.DEPLOY_ENV} || true
                    """
                }
            }
        }
        always {
            sh 'docker logout ${DOCKER_REGISTRY} || true'
        }
    }
}
EOFPIPE
# 환경변수 치환
sed -i "s/\${SERVER_IP}/$SERVER_IP/g" Jenkinsfile
echo "✅ Jenkinsfile 생성 완료"
```

6-7. 생성된 파일 확인

```bash
cd /data/svn-workspace/lib-seoul-trunk/config
echo "=== 생성된 파일 확인 ==="
ls -lh Jenkinsfile k8s/deployment-*.yaml
echo -e "\n=== Jenkinsfile 내용 확인 (첫 30줄) ==="
head -30 Jenkinsfile
echo -e "\n=== Kubernetes 매니페스트 확인 ==="
ls -la k8s/
```

6-8. SVN 상태 확인 및 커밋

```bash
cd /data/svn-workspace/lib-seoul-trunk/config
# SVN 상태 확인
svn status
# 새 파일 추가
svn add k8s 2>/dev/null || true
svn add Jenkinsfile 2>/dev/null || true
# 변경사항 확인
svn status
# 커밋
svn commit -m "Add Jenkinsfile and Kubernetes manifests for config service"
```

**예상 출력:**

```
Adding         k8s
Adding         k8s/deployment-dev.yaml
Adding         k8s/deployment-prod.yaml
Adding         Jenkinsfile
Committed revision XX.
```

6-9. Jenkins Pipeline Job 생성웹 브라우저에서 Jenkins 접속:

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "=============================="
echo "Jenkins URL: http://$SERVER_IP:8080"
echo "Username: admin"
echo "Password: admin123"
echo "=============================="
```

Jenkins 웹에서:

1. Jenkins 대시보드 → New Item 클릭
2. Job 설정:

```
   Enter an item name: config-pipeline
   Type: Pipeline
```

-   OK 클릭

3. General 섹션:
    - ☑ This project is parameterized 체크
    - Add Parameter → Choice Parameter

```
     Name: DEPLOY_ENV
     Choices: (한 줄에 하나씩)
       dev
       prod
     Description: 배포 환경 선택
```

4. Build Triggers 섹션:
    - ☑ Poll SCM 체크
    - Schedule: H/5 \* \* \* \* (5분마다 체크)
5. Pipeline 섹션:

```
   Definition: Pipeline script from SCM
   SCM: Subversion
```

Repository URL:

```
   http://10.10.1.3/svn/lib.seoul.go.kr/trunk/config
   Credentials: svn-credentials 선택
   Script Path: Jenkinsfile
```

6. Save 클릭

6-10. 첫 빌드 테스트 (수동 실행) Jenkins 웹에서:

1. config-pipeline Job 클릭
2. Build with Parameters 클릭
3. DEPLOY_ENV: dev 선택
4. Build 클릭
5. 콘솔 출력 확인:
    - 좌측 메뉴 → #1 (빌드 번호) 클릭 → Console Output

✅ 6단계 확인사항

```bash
cd /data/svn-workspace/lib-seoul-trunk/config
echo "=== 1. 파일 구조 ==="
ls -la Dockerfile Jenkinsfile k8s/ 2>/dev/null
echo -e "\n=== 2. Kubernetes 매니페스트 ==="
ls -la k8s/
echo -e "\n=== 3. Gradle 파일 ==="
ls -lh build.gradle gradlew
echo -e "\n=== 4. SVN 상태 ==="
svn info | grep -E "URL|Revision"
echo -e "\n=== 5. SVN 커밋 확인 ==="
svn log -l 1
echo -e "\n=== 6. Jenkins Job 확인 ==="
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "Jenkins Job: http://$SERVER_IP:8080/job/config-pipeline/"
echo -e "\n=== 7. 시스템 요약 ==="
echo "✅ 서비스: config"
echo "✅ 빌드: Gradle"
echo "✅ Registry: $SERVER_IP:5000"
echo "✅ SVN: http://10.10.1.3/svn/lib.seoul.go.kr/trunk/config"
```
