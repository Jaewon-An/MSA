# Jenkins 기반 CI 빌드 가이드

Kubernetes 클러스터 또는 별도 서버에 Jenkins를 설치하고, 소스 코드 빌드·테스트·이미지 빌드 파이프라인을 구성하는 가이드입니다. 01번 문서에서 구성한 단일 노드 Kubernetes를 기준으로 합니다.

---

## 사전 요구사항

- Kubernetes 클러스터 (kubeadm 단일 노드 또는 다중 노드)
- `kubectl` 설정 완료 (`$HOME/.kube/config`)
- Git 저장소 접근 가능 (GitLab 등)
- 컨테이너 레지스트리 접근 (Docker Hub, Harbor, GitLab Registry 등)

---

## 설치 전 확인

### kubectl 설치 및 클러스터 접속
01번 문서에서 이미 설정했다면 생략 가능합니다.

```bash
# kubectl이 없을 경우 (Linux, 클러스터 노드와 동일한 버전 권장)
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/

# 클러스터 접속 확인
kubectl cluster-info
kubectl get nodes
```

**예상:** `cluster-info`에서 API Server 주소가 보이고, `get nodes`에서 노드가 `Ready` 상태여야 합니다.

### 스토리지 클래스 확인 (PVC 사용 시)
Jenkins용 PVC를 사용하려면 기본 StorageClass가 있거나, 수동으로 PV를 준비해야 합니다.

```bash
kubectl get storageclass
```

**예상:** `default` 표시가 있는 StorageClass가 있으면 PVC가 자동 바인딩됩니다.

**`No resources found`인 경우:** 아래 중 하나로 StorageClass를 구성한 뒤 Jenkins PVC 단계를 진행합니다.

#### (A) local-path-provisioner 설치 (단일 노드 권장)
노드 로컬 디스크에 볼륨을 자동 생성합니다. 01번 문서의 단일 노드 클러스터에 적합합니다.

```bash
# Rancher local-path-provisioner 배포 (기본 저장 경로: /opt/local-path-provisioner)
kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.28/deploy/local-path-storage.yaml

# default StorageClass로 지정 (선택)
kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

# 확인
kubectl get storageclass
kubectl get pods -n local-path-storage
```

**예상:** `local-path` StorageClass가 보이고, `local-path-storage` 네임스페이스의 Pod가 `Running`이면 PVC가 자동으로 바인딩됩니다.

#### (B) 수동 PV/PVC (StorageClass 없이)
StorageClass를 쓰지 않고, 미리 만든 PV에 PVC를 바인딩하는 방식입니다. 1-2의 PVC YAML에 `storageClassName: ""`를 넣고, 아래처럼 PV를 하나 만든 뒤 사용합니다.

```yaml
# jenkins-pv.yaml (노드 경로는 실제 존재하는 디렉터리로 변경)
apiVersion: v1
kind: PersistentVolume
metadata:
  name: jenkins-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: ""
  hostPath:
    path: /data/jenkins
    type: DirectoryOrCreate
```

```bash
# 노드에 디렉터리 생성 (Jenkins가 배포될 노드에서)
sudo mkdir -p /data/jenkins
sudo chown 1000:1000 /data/jenkins

kubectl apply -f jenkins-pv.yaml
```

1-2의 PVC에는 `storageClassName: ""`를 추가하고, `volumeName: jenkins-pv`를 지정하면 해당 PV에 바인딩됩니다.

---

## 1단계: Jenkins 네임스페이스 및 PVC

### 1-1. 네임스페이스 생성
```bash
kubectl create namespace jenkins
```

### 1-2. PersistentVolumeClaim (선택)
Jenkins 데이터 영속화를 위해 PVC를 생성합니다.

```yaml
# jenkins-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pvc
  namespace: jenkins
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

```bash
kubectl apply -f jenkins-pvc.yaml
```

---

## 2단계: Jenkins 배포 (Deployment + Service)

### 2-1. Jenkins Deployment
```yaml
# jenkins-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: jenkins
          image: jenkins/jenkins:lts-jdk17
          ports:
            - containerPort: 8080
            - containerPort: 50000
          env:
            - name: JAVA_OPTS
              value: "-Djenkins.install.runSetupWizard=false -Xmx1024m"
          volumeMounts:
            - name: jenkins-home
              mountPath: /var/jenkins_home
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
      volumes:
        - name: jenkins-home
          persistentVolumeClaim:
            claimName: jenkins-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080
      name: http
    - port: 50000
      targetPort: 50000
      name: agent
  selector:
    app: jenkins
```

```bash
kubectl apply -f jenkins-deployment.yaml
```

### 2-2. Jenkins 기동 대기
```bash
kubectl rollout status deployment/jenkins -n jenkins
kubectl get pods -n jenkins
```

**예상:** Pod가 `Running`이 되면 브라우저에서 `http://<노드IP>:30080`으로 접속합니다.

### 2-3. 초기 비밀번호 확인
```bash
kubectl exec -n jenkins deployment/jenkins -- cat /var/jenkins_home/secrets/initialAdminPassword
```

### 2-4. 설치 검증
```bash
# Pod 정상 기동
kubectl get pods -n jenkins -l app=jenkins

# 서비스 포트 확인
kubectl get svc -n jenkins jenkins
```

**예상:** Pod가 `Running`, Service의 NodePort(30080)가 보이면 브라우저로 `http://<노드IP>:30080` 접속 후 초기 설정을 진행합니다.

---

## (대안) Helm으로 Jenkins 설치

Kubernetes에 Helm이 설치되어 있다면 아래 방식으로 설치할 수 있습니다. 기존 수동 배포와 동시에 사용하지 마세요.

```bash
# Helm repo 추가
helm repo add jenkins https://charts.jenkins.io
helm repo update

# 네임스페이스 생성
kubectl create namespace jenkins

# 설치 (필요 시 values.yaml로 커스터마이즈)
helm install jenkins jenkins/jenkins -n jenkins \
  --set controller.serviceType=NodePort \
  --set controller.nodePort=30080
```

초기 비밀번호 확인:
```bash
kubectl exec -n jenkins svc/jenkins -c jenkins -- cat /var/jenkins_home/secrets/initialAdminPassword
```

---

## 3단계: Jenkins 기본 설정

### 3-1. 필수 플러그인
- **Pipeline**, **Git**, **Kubernetes**, **Docker Pipeline**, **Credentials** 등 설치
- Manage Jenkins → Plugins → Available에서 검색 후 설치

### 3-2. Kubernetes 연동 (Jenkins Agent)
Manage Jenkins → Nodes → Configure Clouds → Add a new cloud → Kubernetes

- Kubernetes URL: `https://kubernetes.default` (클러스터 내부)
- Jenkins URL: `http://jenkins.jenkins.svc.cluster.local:8080`
- Pod Template: JNLP 이미지 등 필요 시 커스텀

### 3-3. GitLab / 레지스트리 Credentials
- Manage Jenkins → Credentials → Add
- Username/Password 또는 SSH Key로 Git 저장소, Docker 레지스트리 등록

---

## 4단계: 파이프라인 Job 예시 (Jenkinsfile)

### 4-1. Pipeline Job 생성
- New Item → Pipeline
- Pipeline definition: **Pipeline script from SCM**
- SCM: Git, Repository URL에 GitLab 저장소 URL 입력
- Script Path: `Jenkinsfile`

### 4-2. Jenkinsfile 예시 (빌드 → 테스트 → 이미지 빌드)
```groovy
pipeline {
  agent any
  environment {
    REGISTRY = 'your-registry.io'
    IMAGE_NAME = 'myapp'
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build') {
      steps {
        sh 'mvn clean package -DskipTests'
        // 또는: npm ci && npm run build
      }
    }
    stage('Test') {
      steps {
        sh 'mvn test'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${REGISTRY}/${IMAGE_NAME}:${env.BUILD_NUMBER}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${REGISTRY}/${IMAGE_NAME}:${env.BUILD_NUMBER}").push()
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
```

---

## 5단계: 동작 확인

### 5-1. 파이프라인 실행
- Job 실행 후 Console Output에서 단계별 로그 확인
- 빌드 산출물 및 이미지 푸시 여부 확인

### 5-2. ArgoCD 연동 시
빌드된 이미지 태그를 Git 레포지토리(Helm/Kustomize 매니페스트)에 반영하거나, ArgoCD에서 이미지 업데이트 정책으로 자동 반영하도록 구성할 수 있습니다. (03. ArgoCD 배포 가이드 참고)

---

## 요약 및 참고

| 항목 | 내용 |
|------|------|
| 네임스페이스 | jenkins |
| 접속 URL | http://\<노드IP\>:30080 |
| 초기 비밀번호 | `kubectl exec ... initialAdminPassword` |
| 파이프라인 | Jenkinsfile 기반, SCM 연동 |

- **Helm 설치:** `helm repo add jenkins https://charts.jenkins.io` 후 `helm install jenkins jenkins/jenkins -n jenkins` 로 대체 가능
- **문제 발생 시:** `kubectl logs -n jenkins deployment/jenkins -f` 로 로그 확인
