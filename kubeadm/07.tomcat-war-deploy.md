# Tomcat + WAR Kubernetes 배포 가이드 (kubeadm 환경)

01·02번 문서로 구성한 kubeadm 단일 노드 클러스터에 **Tomcat 기반 WAR 애플리케이션**을 배포하는 가이드입니다. WAR를 포함한 Docker 이미지를 빌드하고, Private Registry에 푸시한 뒤 Kubernetes
Deployment·Service로 실행합니다.

---

## 사전 요구사항

- 01번 문서 완료: Kubernetes 단일 노드 동작 중 (`kubectl get nodes` 정상)
- 02번 문서 완료(권장): Private Docker Registry 동작 중 — 이미지 push/pull용
- WAR 파일: 빌드된 단일 WAR(로컬 또는 Jenkins 등 CI 산출물)
- 배포 수행 환경: `kubectl` 설정 완료, Registry 사용 시 Docker 로그인 또는 imagePullSecrets 준비

---

## 설치 전 확인

### 클러스터 및 kubectl

```bash
kubectl get nodes
kubectl get pods -A
```

노드가 `Ready` 상태여야 합니다.

### Registry 사용 시 (02번 문서 기준)

Private Registry를 쓰는 경우, 이미지 push를 할 머신에서 Docker 로그인이 되어 있어야 합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
docker login $SERVER_IP:5000
# Username / Password: 02번 문서에서 설정한 값
```

**예상:** `Login Succeeded`

---

## 1단계: WAR 파일 및 프로젝트 디렉터리 준비

배포할 WAR 파일을 넣을 디렉터리를 만들고, WAR를 복사합니다. (Jenkins에서 빌드한 경우 해당 경로에서 복사하거나, 빌드 산출물 경로를 아래 경로로 맞춥니다.)

```bash
# 예: 애플리케이션명 h-cms
APP_NAME=h-cms
mkdir -p ~/tomcat-war-deploy/$APP_NAME
cd ~/tomcat-war-deploy/$APP_NAME

# WAR 파일 복사 (실제 경로는 환경에 맞게 변경)
cp /path/to/your/app.war ./app.war
ls -la app.war
```

**예상:** `app.war` 파일이 존재합니다.

### 설정 파일 디렉터리 준비 (컨테이너 바깥 볼륨용)

Tomcat 설정 파일(예: `server.xml`, `context.xml`)을 컨테이너 바깥(호스트)에 두려면, 노드에 디렉터리를 만들고 필요한 설정 파일을 넣습니다.

```bash
# 설정 디렉터리 생성 (위에서 APP_NAME, ~/tomcat-war-deploy 사용 중이라면)
mkdir -p ~/tomcat-war-deploy/$APP_NAME/conf
cd ~/tomcat-war-deploy/$APP_NAME/conf

# Tomcat 기본 설정 복사 (한 번만 실행). 임시 컨테이너에서 추출
docker run --rm -v $(pwd):/out tomcat:9-jdk8 cp -r /usr/local/tomcat/conf/. /out/
ls -la
```

**예상:** `server.xml`, `context.xml`, `web.xml` 등이 `conf/` 아래에 생성됩니다. 필요에 따라 수정한 뒤, 5단계 Deployment에서 이 경로를 hostPath 볼륨으로 마운트합니다.

> 노드 경로를 다르게 쓸 경우(예: `/opt/tomcat-deploy/$APP_NAME/conf`) 해당 경로를 만들어 두고, 아래 Deployment의 `volumes.hostPath.path` 값을 그 경로로 맞춥니다.

---

## 2단계: Dockerfile 작성

Tomcat 공식 이미지를 사용하고, WAR를 `webapps`에 넣어 루트 컨텍스트(`/`)로 서비스하는 예시입니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/Dockerfile`

```dockerfile
# Tomcat 9 + JDK 8 (Servlet 4.0 / Java EE 8). Jakarta EE 9+ WAR는 tomcat:10.1-jre17 등으로 변경
FROM tomcat:9-jdk8

# WAR 배치: 루트 컨텍스트(/)로 서비스하려면 ROOT.war로 복사
COPY app.war /usr/local/tomcat/webapps/ROOT.war

EXPOSE 8080
```

- **Jakarta EE 9+ / Servlet 5+ WAR**인 경우 첫 줄을 `FROM tomcat:10.1-jre17` 등으로 변경합니다.
- **컨텍스트 경로**를 `/h-cms`처럼 쓰려면 `COPY app.war /usr/local/tomcat/webapps/h-cms.war` 로 두고, 서비스 접근 시 `/h-cms`으로 호출하면 됩니다.

---

## 3단계: 이미지 빌드 및 Registry 푸시

같은 디렉터리에 `app.war`와 `Dockerfile`이 있다고 가정합니다.

```bash
cd ~/tomcat-war-deploy/$APP_NAME
SERVER_IP=$(hostname -I | awk '{print $1}')
IMAGE=$SERVER_IP:5000/$APP_NAME:latest

docker build -t $IMAGE .
docker push $IMAGE
```

**예상:** 빌드 성공 후 `docker push`로 레지스트리에 이미지가 등록됩니다.

---

## 4단계: 네임스페이스 및 imagePullSecrets (Private Registry 사용 시)

Kubernetes에서 Private Registry 이미지를 pull하려면 시크릿이 필요합니다.

```bash
# 네임스페이스 생성 (예: dev)
NAMESPACE=dev
kubectl create namespace $NAMESPACE

# Registry 로그인 정보로 시크릿 생성 (02번 문서의 admin / admin123 등)
kubectl create secret docker-registry registry-secret \
  --docker-server=$SERVER_IP:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n $NAMESPACE
```

**예상:** `secret/registry-secret created`

---

## 5단계: Deployment·Service 매니페스트 작성 및 적용

### 5-1. Deployment

**파일:** `~/tomcat-war-deploy/$APP_NAME/deployment.yaml`

아래는 `APP_NAME=h-cms`, `IMAGE`가 `$SERVER_IP:5000/h-cms:latest`라고 가정한 예시입니다. `NAMESPACE=dev`를 사용합니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
    name: h-cms
    namespace: dev
    labels:
        app: h-cms
spec:
    replicas: 1
    selector:
        matchLabels:
            app: h-cms
    template:
        metadata:
            labels:
                app: h-cms
        spec:
            imagePullSecrets:
                - name: registry-secret
            containers:
                - name: tomcat
                  image: '<REGISTRY_IP>:5000/h-cms:latest'
                  imagePullPolicy: Always
                  ports:
                      - containerPort: 8080
                  volumeMounts:
                      # Tomcat 설정 디렉터리를 컨테이너 바깥(호스트) 볼륨으로 마운트
                      - name: tomcat-conf
                        mountPath: /usr/local/tomcat/conf
                        readOnly: false
                  resources:
                      requests:
                          memory: '256Mi'
                          cpu: '100m'
                      limits:
                          memory: '512Mi'
                          cpu: '500m'
                  livenessProbe:
                      httpGet:
                          path: /
                          port: 8080
                      initialDelaySeconds: 60
                      periodSeconds: 10
                  readinessProbe:
                      httpGet:
                          path: /
                          port: 8080
                      initialDelaySeconds: 30
                      periodSeconds: 5
            volumes:
                # 호스트의 설정 디렉터리. 경로는 노드 환경에 맞게 변경 (예: /opt/tomcat-deploy/h-cms/conf)
                - name: tomcat-conf
                  hostPath:
                      path: /root/tomcat-war-deploy/h-cms/conf
                      type: DirectoryOrCreate
---
apiVersion: v1
kind: Service
metadata:
    name: h-cms
    namespace: dev
spec:
    selector:
        app: h-cms
    ports:
        - port: 80
          targetPort: 8080
    type: ClusterIP
```

**적용 전:**
- `image`의 `<REGISTRY_IP>`를 **실제 IP 또는 호스트명**으로 반드시 바꿉니다. 그대로 두면 `InvalidImageName`이 발생합니다.
- 설정 볼륨을 쓰는 경우 `volumes[].hostPath.path`를 1단계에서 만든 **노드의 실제 경로**로 맞춥니다(예: `~/tomcat-war-deploy/h-cms/conf` → `/root/tomcat-war-deploy/h-cms/conf` 또는 사용자 홈 기준 경로).

```bash
# 변수로 치환하여 적용하는 예 (동일 셸에서 SERVER_IP 설정 후 실행)
SERVER_IP=$(hostname -I | awk '{print $1}')
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 편집기로 `image` 값을 `192.168.x.x:5000/h-cms:latest` 형태로 수정한 뒤:

```bash
kubectl apply -f deployment.yaml
```

**예상:** `deployment.apps/h-cms created`, `service/h-cms created`

---

## 6단계: 배포 확인

### Pod·Service 상태

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

**예상:** Pod가 `Running`, Service가 `ClusterIP`로 생성됩니다.

### 로그 확인

```bash
kubectl logs -n dev -l app=h-cms --tail=50 -f
```

### 클러스터 내부에서 접근 테스트 (curl)

```bash
kubectl run curl --rm -it --restart=Never --image=curlimages/curl -n dev -- curl -s -o /dev/null -w "%{http_code}" http://h-cms.dev.svc.cluster.local:80/
```

**예상:** `200` 등 정상 응답 코드.

### 노드에서 포트 포워드로 브라우저 접속 (선택)

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
```

이후 브라우저에서 `http://localhost:8080` 접속하여 WAR 애플리케이션 동작을 확인합니다.

---

## (선택) Ingress로 외부 노출

클러스터에 Ingress Controller(예: NGINX Ingress)가 설치되어 있다면, Ingress 리소스로 서비스를 노출할 수 있습니다.

```yaml
# ingress.yaml (예시)
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
    name: h-cms
    namespace: dev
spec:
    ingressClassName: nginx
    rules:
        - host: h-cms.example.com
          http:
              paths:
                  - path: /
                    pathType: Prefix
                    backend:
                        service:
                            name: h-cms
                            port:
                                number: 80
```

```bash
kubectl apply -f ingress.yaml
```

---

## 재배포 절차 (InvalidImageName / ImagePullBackOff 해결)

Pod가 `InvalidImageName` 또는 `ImagePullBackOff`일 때 아래 순서로 재배포합니다.

### 1. Registry IP 확인 및 이미지 주소 확인

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo $SERVER_IP:5000/h-cms:latest
```

### 2. 이미지 재빌드 및 Registry 푸시

```bash
cd ~/tomcat-war-deploy/h-cms
docker build -t $SERVER_IP:5000/h-cms:latest .
docker push $SERVER_IP:5000/h-cms:latest
```

### 3. Deployment 이미지 주소 수정 후 재적용

매니페스트의 `image`가 `<REGISTRY_IP>`로 되어 있으면 실제 IP로 바꾼 뒤 적용합니다.

```bash
cd ~/tomcat-war-deploy/h-cms
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 수동 수정 후:

```bash
kubectl apply -f deployment.yaml
```

### 4. 기존 Pod 삭제 후 새 Pod 생성 (재배포)

```bash
kubectl delete pods -n dev -l app=h-cms
```

### 5. 상태 확인

```bash
kubectl get pods -n dev -l app=h-cms
```

**예상:** 새 Pod가 생성되고 `Running` / `READY 1/1`로 전환됩니다.

이후에도 실패하면 `kubectl describe pod -n dev -l app=h-cms`로 Events를 확인하고, registry-secret 및 이미지 주소를 점검합니다.

---

## 요약

| 단계 | 내용                                 |
| ---- | ------------------------------------ |
| 1    | WAR 및 프로젝트 디렉터리 준비, 설정 디렉터리(conf) 준비(선택) |
| 2    | Tomcat + WAR Dockerfile 작성         |
| 3    | 이미지 빌드 후 Private Registry push |
| 4    | 네임스페이스·imagePullSecrets 생성   |
| 5    | Deployment·Service 매니페스트 적용(설정 볼륨 hostPath 포함) |
| 6    | Pod/Service/로그·접근 확인           |

- **기존 기능 유지:** 01·02번 문서로 구성한 클러스터·Registry는 그대로 두고, WAR 앱만 추가 배포하는 형태입니다.
- **Jenkins 연동:** 04번 문서의 파이프라인에서 WAR 빌드 → 위 Dockerfile로 이미지 빌드 → 동일 Registry push → `kubectl apply` 또는 Argo CD(05번)로 배포하도록 확장할 수 있습니다.
