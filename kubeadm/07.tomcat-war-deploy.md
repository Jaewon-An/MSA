# Tomcat + WAR Kubernetes 배포 가이드 (kubeadm 환경)

01·02번 문서로 구성한 kubeadm 단일 노드 클러스터에 **Tomcat 기반 WAR 애플리케이션**을 배포하는 가이드입니다. WAR를 포함한 Docker 이미지를 빌드하고, Private Registry에 푸시한 뒤 Kubernetes Deployment·Service로 실행합니다.

---

## 사전 요구사항

- 01번 문서 완료: Kubernetes 단일 노드 동작 중 (`kubectl get nodes` 정상)
- 02번 문서 완료(권장): Private Docker Registry 동작 중 — 이미지 push/pull용
- WAR 파일: 빌드된 단일 WAR(로컬 또는 Jenkins 등 CI 산출물)
- 배포 수행 환경: `kubectl` 설정 완료, Registry 사용 시 Docker 로그인 또는 imagePullSecrets 준비

---

## 설치 전 확인

### 클러스터 및 kubectl
```bash
kubectl get nodes
kubectl get pods -A
```
노드가 `Ready` 상태여야 합니다.

### Registry 사용 시 (02번 문서 기준)
Private Registry를 쓰는 경우, 이미지 push를 할 머신에서 Docker 로그인이 되어 있어야 합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
docker login $SERVER_IP:5000
# Username / Password: 02번 문서에서 설정한 값
```

**예상:** `Login Succeeded`

---

## 1단계: WAR 파일 및 프로젝트 디렉터리 준비

배포할 WAR 파일을 넣을 디렉터리를 만들고, WAR를 복사합니다. (Jenkins에서 빌드한 경우 해당 경로에서 복사하거나, 빌드 산출물 경로를 아래 경로로 맞춥니다.)

```bash
# 예: 애플리케이션명 myapp
APP_NAME=myapp
mkdir -p ~/tomcat-war-deploy/$APP_NAME
cd ~/tomcat-war-deploy/$APP_NAME

# WAR 파일 복사 (실제 경로는 환경에 맞게 변경)
cp /path/to/your/app.war ./app.war
ls -la app.war
```

**예상:** `app.war` 파일이 존재합니다.

> **Jenkins 파이프라인에서 WAR 빌드 시:** Gradle `war` 태스크 또는 Maven `package` 산출물 경로를 위 `APP_NAME` 디렉터리로 복사하거나, 빌드 Job의 워크스페이스 경로를 기준으로 Dockerfile에서 `COPY` 경로를 맞추면 됩니다.

---

## 2단계: Dockerfile 작성

Tomcat 공식 이미지를 사용하고, WAR를 `webapps`에 넣어 루트 컨텍스트(`/`)로 서비스하는 예시입니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/Dockerfile`

```dockerfile
# Tomcat 10.1 (Jakarta EE 9+). Servlet 4.0 / Java EE 8 WAR는 tomcat:9-jre17 등으로 변경
FROM tomcat:10.1-jre17

# WAR 배치: 루트 컨텍스트(/)로 서비스하려면 ROOT.war로 복사
COPY app.war /usr/local/tomcat/webapps/ROOT.war

EXPOSE 8080
```

- **Servlet 4.0 / Java EE 8 WAR**인 경우 첫 줄을 `FROM tomcat:9-jre17` 또는 `FROM tomcat:9-jre11`로 변경합니다.
- **컨텍스트 경로**를 `/myapp`처럼 쓰려면 `COPY app.war /usr/local/tomcat/webapps/myapp.war` 로 두고, 서비스 접근 시 `/myapp`으로 호출하면 됩니다.

---

## 3단계: 이미지 빌드 및 Registry 푸시

같은 디렉터리에 `app.war`와 `Dockerfile`이 있다고 가정합니다.

```bash
cd ~/tomcat-war-deploy/$APP_NAME
SERVER_IP=$(hostname -I | awk '{print $1}')
IMAGE=$SERVER_IP:5000/$APP_NAME:latest

docker build -t $IMAGE .
docker push $IMAGE
```

**예상:** 빌드 성공 후 `docker push`로 레지스트리에 이미지가 등록됩니다.

---

## 4단계: 네임스페이스 및 imagePullSecrets (Private Registry 사용 시)

Kubernetes에서 Private Registry 이미지를 pull하려면 시크릿이 필요합니다.

```bash
# 네임스페이스 생성 (예: dev)
NAMESPACE=dev
kubectl create namespace $NAMESPACE

# Registry 로그인 정보로 시크릿 생성 (02번 문서의 admin / admin123 등)
kubectl create secret docker-registry registry-secret \
  --docker-server=$SERVER_IP:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n $NAMESPACE
```

**예상:** `secret/registry-secret created`

---

## 5단계: Deployment·Service 매니페스트 작성 및 적용

### 5-1. Deployment

**파일:** `~/tomcat-war-deploy/$APP_NAME/deployment.yaml`

아래는 `APP_NAME=myapp`, `IMAGE`가 `$SERVER_IP:5000/myapp:latest`라고 가정한 예시입니다. `NAMESPACE=dev`를 사용합니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: dev
  labels:
    app: myapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      imagePullSecrets:
        - name: registry-secret
      containers:
        - name: tomcat
          image: "<REGISTRY_IP>:5000/myapp:latest"
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: dev
spec:
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP
```

**적용 전:** `image`의 `<REGISTRY_IP>`를 실제 Registry 주소(예: 노드 IP)로 바꿉니다.

```bash
# 변수로 치환하여 적용하는 예
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 편집기로 `image` 값을 `$SERVER_IP:5000/myapp:latest` 형태로 수정한 뒤:

```bash
kubectl apply -f deployment.yaml
```

**예상:** `deployment.apps/myapp created`, `service/myapp created`

---

## 6단계: 배포 확인

### Pod·Service 상태
```bash
kubectl get pods -n dev -l app=myapp
kubectl get svc -n dev myapp
```

**예상:** Pod가 `Running`, Service가 `ClusterIP`로 생성됩니다.

### 로그 확인
```bash
kubectl logs -n dev -l app=myapp --tail=50 -f
```

### 클러스터 내부에서 접근 테스트 (curl)
```bash
kubectl run curl --rm -it --restart=Never --image=curlimages/curl -n dev -- curl -s -o /dev/null -w "%{http_code}" http://myapp.dev.svc.cluster.local:80/
```

**예상:** `200` 등 정상 응답 코드.

### 노드에서 포트 포워드로 브라우저 접속 (선택)
```bash
kubectl port-forward -n dev svc/myapp 8080:80
```
이후 브라우저에서 `http://localhost:8080` 접속하여 WAR 애플리케이션 동작을 확인합니다.

---

## (선택) Ingress로 외부 노출

클러스터에 Ingress Controller(예: NGINX Ingress)가 설치되어 있다면, Ingress 리소스로 서비스를 노출할 수 있습니다.

```yaml
# ingress.yaml (예시)
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp
  namespace: dev
spec:
  ingressClassName: nginx
  rules:
    - host: myapp.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp
                port:
                  number: 80
```

```bash
kubectl apply -f ingress.yaml
```

---

## 요약

| 단계 | 내용 |
|------|------|
| 1 | WAR 및 프로젝트 디렉터리 준비 |
| 2 | Tomcat + WAR Dockerfile 작성 |
| 3 | 이미지 빌드 후 Private Registry push |
| 4 | 네임스페이스·imagePullSecrets 생성 |
| 5 | Deployment·Service 매니페스트 적용 |
| 6 | Pod/Service/로그·접근 확인 |

- **기존 기능 유지:** 01·02번 문서로 구성한 클러스터·Registry는 그대로 두고, WAR 앱만 추가 배포하는 형태입니다.
- **Jenkins 연동:** 04번 문서의 파이프라인에서 WAR 빌드 → 위 Dockerfile로 이미지 빌드 → 동일 Registry push → `kubectl apply` 또는 Argo CD(05번)로 배포하도록 확장할 수 있습니다.
