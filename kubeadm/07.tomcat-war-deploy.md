# Tomcat + WAR Kubernetes 배포 가이드 (kubeadm 환경)

01·02번 문서로 구성한 kubeadm 단일 노드 클러스터에 **Tomcat 기반 WAR 애플리케이션**을 배포하는 가이드입니다. WAR를 포함한 Docker 이미지를 빌드하고, Private Registry에 푸시한 뒤 Kubernetes
Deployment·Service로 실행합니다.

---

## 사전 요구사항

- 01번 문서 완료: Kubernetes 단일 노드 동작 중 (`kubectl get nodes` 정상)
- 02번 문서 완료(권장): Private Docker Registry 동작 중 — 이미지 push/pull용
- WAR 파일: 빌드된 단일 WAR(로컬 또는 Jenkins 등 CI 산출물)
- 배포 수행 환경: `kubectl` 설정 완료, Registry 사용 시 Docker 로그인 또는 imagePullSecrets 준비

---

## 설치 전 확인

01번 문서 완료 상태를 전제로 합니다. 노드가 `Ready`인지 확인합니다.

```bash
kubectl get nodes
kubectl get pods -A
```

### Registry 사용 시 (02번 문서 기준)

Private Registry를 쓰는 경우, 이미지 push를 할 머신에서 Docker 로그인이 되어 있어야 합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
docker login $SERVER_IP:5000
# Username / Password: 02번 문서에서 설정한 값
```

**예상:** `Login Succeeded`

---

## 1단계: WAR 파일 및 프로젝트 디렉터리 준비

배포할 WAR 파일을 넣을 디렉터리를 만들고, WAR를 복사합니다. (Jenkins에서 빌드한 경우 해당 경로에서 복사하거나, 빌드 산출물 경로를 아래 경로로 맞춥니다.)

```bash
# 예: 애플리케이션명 h-cms
APP_NAME=h-cms
mkdir -p ~/tomcat-war-deploy/$APP_NAME
cd ~/tomcat-war-deploy/$APP_NAME

# WAR 파일 복사 (실제 경로는 환경에 맞게 변경)
cp /path/to/your/app.war ./app.war
ls -la app.war
```

**예상:** `app.war` 파일이 존재합니다.

### 설정 파일 디렉터리 준비 (컨테이너 바깥 볼륨용)

Tomcat 설정 파일(예: `server.xml`, `context.xml`)을 컨테이너 바깥(호스트)에 두려면, 노드에 디렉터리를 만들고 필요한 설정 파일을 넣습니다.

```bash
# 설정 디렉터리 생성 (위에서 APP_NAME, ~/tomcat-war-deploy 사용 중이라면)
mkdir -p ~/tomcat-war-deploy/$APP_NAME/conf
cd ~/tomcat-war-deploy/$APP_NAME/conf

# Tomcat 기본 설정 복사 (한 번만 실행). 임시 컨테이너에서 추출
docker run --rm -v $(pwd):/out tomcat:9-jdk8 cp -r /usr/local/tomcat/conf/. /out/
ls -la
```

**예상:** `server.xml`, `context.xml`, `web.xml` 등이 `conf/` 아래에 생성됩니다. 필요에 따라 수정한 뒤, 5단계 Deployment에서 이 경로를 hostPath 볼륨으로 마운트합니다.

> 노드 경로를 다르게 쓸 경우(예: `/opt/tomcat-deploy/$APP_NAME/conf`) 해당 경로를 만들어 두고, 아래 Deployment의 `volumes.hostPath.path` 값을 그 경로로 맞춥니다.

### context.xml 설정 (JNDI DataSource)

데이터베이스 연결이 필요한 경우 `context.xml` 파일에 JNDI DataSource를 설정할 수 있습니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/conf/context.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Context>
    <!-- JNDI DataSource for ROOT and other web applications -->
    <Resource name="jdbc/cmsdb"
              auth="Container"
              type="javax.sql.DataSource"
              maxTotal="100"
              maxIdle="30"
              maxWaitMillis="10000"
              username="SEOULLIB"
              password="lib#0070"
              driverClassName="oracle.jdbc.driver.OracleDriver"
              url="jdbc:oracle:thin:@10.10.1.1:1521:orcl"/>
</Context>
```

**설정 항목:**
- `name`: JNDI 리소스 이름 (애플리케이션에서 `java:comp/env/jdbc/cmsdb`로 참조)
- `driverClassName`: JDBC 드라이버 클래스명 (Oracle: `oracle.jdbc.driver.OracleDriver`)
- `url`: 데이터베이스 연결 URL
- `username`, `password`: 데이터베이스 인증 정보
- `maxTotal`, `maxIdle`, `maxWaitMillis`: 커넥션 풀 설정

> **참고:** Oracle JDBC 드라이버는 WAR 파일에 포함되어 있어야 합니다. WAR 파일의 `WEB-INF/lib/` 디렉터리에 `ojdbc*.jar` 파일이 포함되어 있는지 확인하세요.

### 외부 디렉토리를 ROOT로 설정 (선택)

ROOT.war 대신 외부 디렉토리를 ROOT 컨텍스트로 사용하려면 아래 설정을 수행합니다.

#### 1. 외부 디렉토리 준비

호스트에 웹 애플리케이션 디렉토리를 생성하고 WAR 파일을 압축 해제합니다.

```bash
# 외부 디렉토리 생성
mkdir -p ~/tomcat-war-deploy/$APP_NAME/webapp
cd ~/tomcat-war-deploy/$APP_NAME/webapp

# WAR 파일 압축 해제 (WAR 파일이 있는 경우)
unzip -q ../app.war -d .
# 또는 기존 압축 해제된 디렉토리를 복사
# cp -r /path/to/extracted/webapp/* .
```

**예상:** `WEB-INF/`, `META-INF/` 등 웹 애플리케이션 구조가 `webapp/` 디렉터리에 생성됩니다.

#### 2. server.xml 설정

`server.xml` 파일에서 ROOT 컨텍스트의 `docBase`를 외부 디렉토리 경로로 설정합니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/conf/server.xml`

```xml
<!-- ROOT context configuration with external directory -->
<Context path="" docBase="/usr/local/tomcat/webapps/external-root" reloadable="true">
</Context>
```

**설정 항목:**
- `path=""`: 루트 컨텍스트(`/`)로 설정
- `docBase`: 외부 디렉토리의 절대 경로 (컨테이너 내부 경로)
- `reloadable="true"`: 자동 리로드 활성화 (개발 환경 권장)

> **참고:** 외부 디렉토리를 사용하면 WAR 파일을 압축 해제할 필요 없이 직접 파일을 수정할 수 있어 개발 및 디버깅이 용이합니다. 또한 Dockerfile에서 WAR 파일을 복사하지 않아도 됩니다.

---

## 2단계: Dockerfile 작성

Tomcat 공식 이미지를 사용하고, WAR를 `webapps`에 넣어 루트 컨텍스트(`/`)로 서비스하는 예시입니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/Dockerfile`

```dockerfile
# Tomcat 9 + JDK 8 (Servlet 4.0 / Java EE 8). Jakarta EE 9+ WAR는 tomcat:10.1-jre17 등으로 변경
FROM tomcat:9-jdk8

# WAR 배치: 루트 컨텍스트(/)로 서비스하려면 ROOT.war로 복사
COPY app.war /usr/local/tomcat/webapps/ROOT.war

EXPOSE 8080
```

- **Jakarta EE 9+ / Servlet 5+ WAR**인 경우 첫 줄을 `FROM tomcat:10.1-jre17` 등으로 변경합니다.
- **컨텍스트 경로**를 `/h-cms`처럼 쓰려면 `COPY app.war /usr/local/tomcat/webapps/h-cms.war` 로 두고, 서비스 접근 시 `/h-cms`으로 호출하면 됩니다.
- **외부 디렉토리를 ROOT로 사용하는 경우**: 외부 디렉토리를 사용하면 WAR 파일을 이미지에 포함시킬 필요가 없습니다. Dockerfile은 다음과 같이 작성합니다:
  ```dockerfile
  FROM tomcat:9-jdk8
  
  # 외부 디렉토리를 ROOT로 사용하므로 WAR 파일 복사 불필요
  # 호스트의 webapp 디렉토리가 컨테이너의 /usr/local/tomcat/webapps/external-root로 마운트됨
  
  EXPOSE 8080
  ```
- **애플리케이션 프로파일 설정**: 프로파일은 Deployment 매니페스트의 `env` 섹션에서 `CATALINA_OPTS`를 통해 JVM 옵션으로 설정합니다 (5단계 참조). `CATALINA_OPTS="-Dprofile=dev"` 형태로 설정하면 애플리케이션에서 `System.getProperty("profile")`로 참조할 수 있습니다. Dockerfile에서 직접 설정하려면 `ENV CATALINA_OPTS="-Dprofile=dev"`를 추가할 수 있지만, Kubernetes 환경 변수로 설정하는 것이 더 유연합니다.

---

## 3단계: 이미지 빌드 및 Registry 푸시

같은 디렉터리에 `app.war`와 `Dockerfile`이 있다고 가정합니다.

```bash
cd ~/tomcat-war-deploy/$APP_NAME
SERVER_IP=$(hostname -I | awk '{print $1}')
IMAGE=$SERVER_IP:5000/$APP_NAME:latest

docker build -t $IMAGE .
docker push $IMAGE
```

**예상:** 빌드 성공 후 `docker push`로 레지스트리에 이미지가 등록됩니다.

---

## 3단계 (대안): Jenkins에서 이미지 빌드·배포

07번과 동일한 Tomcat+WAR 이미지를 **04번 문서의 Jenkins** 파이프라인에서 빌드·푸시하고, 필요 시 **kubectl 배포**까지 한 번에 하려면 **08번 문서 [Jenkins로 Tomcat WAR Kubernetes 배포 가이드](08.jenkins-tomcat-deploy.md)**를 참고하세요. 플러그인·Credentials·Pipeline Job·Jenkinsfile·kubectl 배포 단계가 모두 포함되어 있습니다.

---

## 4단계: 네임스페이스 및 imagePullSecrets (Private Registry 사용 시)

Kubernetes에서 Private Registry 이미지를 pull하려면 시크릿이 필요합니다.

```bash
# 네임스페이스 생성 (예: dev)
NAMESPACE=dev
kubectl create namespace $NAMESPACE

# Registry 로그인 정보로 시크릿 생성 (02번 문서의 admin / admin123 등)
kubectl create secret docker-registry registry-secret \
  --docker-server=$SERVER_IP:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n $NAMESPACE
```

**예상:** `secret/registry-secret created`

---

## 5단계: Deployment·Service 매니페스트 작성 및 적용

### 5-1. Deployment

**파일:** `~/tomcat-war-deploy/$APP_NAME/deployment.yaml`

아래는 `APP_NAME=h-cms`, `IMAGE`가 `$SERVER_IP:5000/h-cms:latest`라고 가정한 예시입니다. `NAMESPACE=dev`를 사용합니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
    name: h-cms
    namespace: dev
    labels:
        app: h-cms
spec:
    replicas: 1
    selector:
        matchLabels:
            app: h-cms
    template:
        metadata:
            labels:
                app: h-cms
        spec:
            imagePullSecrets:
                - name: registry-secret
            containers:
                - name: hcms
                  image: '<REGISTRY_IP>:5000/h-cms:latest'
                  imagePullPolicy: Always
                  ports:
                      - containerPort: 8080
                  env:
                      # Spring 프로파일 활성화
                      - name: SPRING_PROFILES_ACTIVE
                        value: 'dev'
                      # 애플리케이션 프로파일 설정 (dev 환경)
                      # JVM 옵션으로 시스템 프로퍼티 전달
                      # Spring <beans profile="dev"> 활성화에는 spring.profiles.active 시스템 프로퍼티 필요
                      - name: CATALINA_OPTS
                        value: '-Dprofile=dev -Dspring.profiles.active=dev'
                      # 환경 변수로도 설정 (애플리케이션에서 System.getenv()로 참조 가능)
                      - name: PROFILE
                        value: 'dev'
                  volumeMounts:
                      # Tomcat 설정 디렉터리를 컨테이너 바깥(호스트) 볼륨으로 마운트
                      - name: tomcat-conf
                        mountPath: /usr/local/tomcat/conf
                        readOnly: false
                      # 외부 디렉토리를 ROOT로 사용하는 경우 (선택)
                      - name: webapp-root
                        mountPath: /usr/local/tomcat/webapps/external-root
                        readOnly: false
                  resources:
                      requests:
                          memory: '256Mi'
                          cpu: '100m'
                      limits:
                          memory: '512Mi'
                          cpu: '500m'
                  livenessProbe:
                      httpGet:
                          path: /
                          port: 8080
                      initialDelaySeconds: 60
                      periodSeconds: 10
                  readinessProbe:
                      httpGet:
                          path: /
                          port: 8080
                      initialDelaySeconds: 30
                      periodSeconds: 5
            volumes:
                # 호스트의 설정 디렉터리. 경로는 노드 환경에 맞게 변경 (예: /opt/tomcat-deploy/h-cms/conf)
                - name: tomcat-conf
                  hostPath:
                      path: /home/jnet/tomcat-war-deploy/h-cms/conf
                      type: DirectoryOrCreate
                # 외부 디렉토리를 ROOT로 사용하는 경우 (선택)
                - name: webapp-root
                  hostPath:
                      path: /home/jnet/tomcat-war-deploy/h-cms/webapp
                      type: DirectoryOrCreate
---
apiVersion: v1
kind: Service
metadata:
    name: h-cms
    namespace: dev
spec:
    selector:
        app: h-cms
    ports:
        - port: 80
          targetPort: 8080
    type: ClusterIP
```

**적용 전:**
- `image`의 `<REGISTRY_IP>`를 **실제 IP 또는 호스트명**으로 반드시 바꿉니다. 그대로 두면 `InvalidImageName`이 발생합니다.
- 설정 볼륨을 쓰는 경우 `volumes[].hostPath.path`를 1단계에서 만든 **노드의 실제 경로**로 맞춥니다(예: `~/tomcat-war-deploy/h-cms/conf` → `/home/jnet/tomcat-war-deploy/h-cms/conf` 또는 사용자 홈 기준 경로).
- **프로파일 설정**: 
  - `SPRING_PROFILES_ACTIVE`: Spring 프로파일 활성화 (예: `dev`, `prod`, `test`)
  - `CATALINA_OPTS`: JVM 옵션으로 시스템 프로퍼티 전달. `-Dprofile=dev -Dspring.profiles.active=dev` 형태로 설정하면 애플리케이션에서 `System.getProperty("profile")` 및 `System.getProperty("spring.profiles.active")`로 참조할 수 있습니다.
  - `PROFILE`: 환경 변수로 설정 (애플리케이션에서 `System.getenv("PROFILE")`로 참조 가능)
- **JNDI DataSource 설정**: `context.xml` 파일에 데이터베이스 연결 정보를 설정할 수 있습니다. 예시는 아래 "context.xml 설정" 섹션을 참조하세요.
- **외부 디렉토리 설정**: ROOT.war 대신 외부 디렉토리를 사용하는 경우, `webapp-root` 볼륨 마운트를 추가하고 `server.xml`에서 `docBase`를 외부 디렉토리 경로로 설정합니다. 자세한 내용은 "외부 디렉토리를 ROOT로 설정" 섹션을 참조하세요.

```bash
# 변수로 치환하여 적용하는 예 (동일 셸에서 SERVER_IP 설정 후 실행)
SERVER_IP=$(hostname -I | awk '{print $1}')
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 편집기로 `image` 값을 `192.168.x.x:5000/h-cms:latest` 형태로 수정한 뒤:

```bash
kubectl apply -f deployment.yaml
```

**예상:** `deployment.apps/h-cms created`, `service/h-cms created`

---

## 6단계: 배포 확인

### Pod·Service 상태

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

**예상:** Pod가 `Running`, Service가 `ClusterIP`로 생성됩니다.

### 환경 변수 확인 (프로파일 설정 확인)

```bash
# Pod의 환경 변수 확인
POD_NAME=$(kubectl get pods -n dev -l app=h-cms -o jsonpath='{.items[0].metadata.name}')

# SPRING_PROFILES_ACTIVE 확인
kubectl exec -n dev $POD_NAME -- env | grep SPRING_PROFILES_ACTIVE

# CATALINA_OPTS 확인 (JVM 옵션으로 프로파일 전달)
kubectl exec -n dev $POD_NAME -- env | grep CATALINA_OPTS

# PROFILE 환경 변수 확인
kubectl exec -n dev $POD_NAME -- env | grep PROFILE

# 또는 모든 환경 변수 확인
kubectl exec -n dev $POD_NAME -- env | grep -E "(SPRING_PROFILES_ACTIVE|CATALINA_OPTS|PROFILE)"

# 시스템 프로퍼티 확인 (애플리케이션에서 System.getProperty("profile")로 참조 가능)
kubectl exec -n dev $POD_NAME -- sh -c 'echo $CATALINA_OPTS'
```

**예상:** 
- `SPRING_PROFILES_ACTIVE=dev` 출력
- `CATALINA_OPTS=-Dprofile=dev -Dspring.profiles.active=dev` 출력
- `PROFILE=dev` 출력

> **참고:** 프로파일이 제대로 적용되었는지 확인하려면 애플리케이션 로그를 확인하거나, 컨테이너 내부에서 `System.getProperty("profile")` 및 `System.getProperty("spring.profiles.active")` 값을 확인할 수 있습니다. 애플리케이션 코드에서 다른 프로퍼티명을 사용하는 경우(예: `app.profile`, `env` 등) `CATALINA_OPTS` 값을 해당 프로퍼티명에 맞게 수정합니다.

### 로그 확인

#### 컨테이너 표준 출력/에러 로그 (kubectl logs)

Pod의 표준 출력/에러 로그를 확인합니다. Tomcat의 기본 로그는 여기에 출력됩니다.

```bash
# 실시간 로그 확인 (tail -f)
kubectl logs -n dev -l app=h-cms --tail=50 -f

# 특정 Pod의 로그 확인
POD_NAME=$(kubectl get pods -n dev -l app=h-cms -o jsonpath='{.items[0].metadata.name}')
kubectl logs -n dev $POD_NAME --tail=100

# 이전 컨테이너 로그 확인 (재시작된 경우)
kubectl logs -n dev $POD_NAME --previous

# 특정 시간 이후 로그 확인
kubectl logs -n dev $POD_NAME --since=1h
```

#### Tomcat 로그 파일 확인

Tomcat은 `/usr/local/tomcat/logs/` 디렉터리에 다양한 로그 파일을 생성합니다. 컨테이너 내부에 접속하여 확인할 수 있습니다.

```bash
# Pod 이름 확인
POD_NAME=$(kubectl get pods -n dev -l app=h-cms -o jsonpath='{.items[0].metadata.name}')

# 컨테이너 내부 접속
kubectl exec -it -n dev $POD_NAME -- /bin/bash

# 컨테이너 내부에서 로그 파일 확인
ls -la /usr/local/tomcat/logs/
tail -f /usr/local/tomcat/logs/catalina.out
tail -f /usr/local/tomcat/logs/localhost.$(date +%Y-%m-%d).log
```

또는 kubectl exec로 직접 로그 파일 내용을 확인:

```bash
# catalina.out 로그 확인 (Tomcat 시작 로그)
kubectl exec -n dev $POD_NAME -- tail -100 /usr/local/tomcat/logs/catalina.out

# localhost 로그 확인 (애플리케이션 로그)
kubectl exec -n dev $POD_NAME -- tail -100 /usr/local/tomcat/logs/localhost.$(date +%Y-%m-%d).log

# manager 로그 확인 (Tomcat Manager 접근 로그)
kubectl exec -n dev $POD_NAME -- tail -100 /usr/local/tomcat/logs/manager.$(date +%Y-%m-%d).log

# host-manager 로그 확인
kubectl exec -n dev $POD_NAME -- tail -100 /usr/local/tomcat/logs/host-manager.$(date +%Y-%m-%d).log

# 모든 로그 파일 목록 확인
kubectl exec -n dev $POD_NAME -- ls -lh /usr/local/tomcat/logs/
```

#### 실시간 로그 모니터링

```bash
# 여러 로그 파일을 동시에 모니터링
POD_NAME=$(kubectl get pods -n dev -l app=h-cms -o jsonpath='{.items[0].metadata.name}')
kubectl exec -n dev $POD_NAME -- sh -c 'tail -f /usr/local/tomcat/logs/catalina.out /usr/local/tomcat/logs/localhost.*.log'
```

#### 로그 파일 위치

Tomcat의 주요 로그 파일 위치:

- `/usr/local/tomcat/logs/catalina.out`: Tomcat 시작/종료 및 표준 출력 로그
- `/usr/local/tomcat/logs/localhost.YYYY-MM-DD.log`: 애플리케이션 로그 (WAR 애플리케이션의 로그 포함)
- `/usr/local/tomcat/logs/manager.YYYY-MM-DD.log`: Tomcat Manager 접근 로그
- `/usr/local/tomcat/logs/host-manager.YYYY-MM-DD.log`: Host Manager 로그
- `/usr/local/tomcat/logs/catalina.YYYY-MM-DD.log`: Tomcat 엔진 로그

> **참고:** 로그 파일은 날짜별로 생성되며, `server.xml`의 `logging.properties` 설정에 따라 로그 형식과 위치가 달라질 수 있습니다.

### 클러스터 내부에서 접근 테스트 (curl)

```bash
kubectl run curl --rm -it --restart=Never --image=curlimages/curl -n dev -- curl -s -o /dev/null -w "%{http_code}" http://h-cms.dev.svc.cluster.local:80/
```

**예상:** `200` 등 정상 응답 코드.

### 노드에서 포트 포워드로 브라우저 접속 (선택)

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
```

이후 브라우저에서 `http://localhost:8080` 접속하여 WAR 애플리케이션 동작을 확인합니다.

---

## Pod 재시작 방법

설정 파일 변경이나 애플리케이션 재시작이 필요한 경우 Pod를 재시작할 수 있습니다.

### 방법 1: Deployment 롤아웃 재시작 (권장)

Deployment를 재시작하면 새 Pod가 생성되고 기존 Pod는 정상적으로 종료됩니다. 가장 안전한 방법입니다.

```bash
kubectl rollout restart deployment/h-cms -n dev
```

**예상:** `deployment.apps/h-cms restarted`

재시작 상태 확인:

```bash
kubectl get pods -n dev -l app=h-cms -w
```

**예상:** 기존 Pod가 `Terminating` 상태로 전환되고, 새 Pod가 `Pending` → `ContainerCreating` → `Running` 상태로 전환됩니다.

### 방법 2: Pod 직접 삭제

Pod를 직접 삭제하면 Deployment가 자동으로 새 Pod를 생성합니다.

```bash
# Pod 이름 확인
kubectl get pods -n dev -l app=h-cms

# Pod 삭제 (Pod 이름은 위에서 확인한 값으로 교체)
kubectl delete pod <pod-name> -n dev

# 또는 레이블로 여러 Pod 삭제
kubectl delete pods -n dev -l app=h-cms
```

**예상:** `pod "<pod-name>" deleted` 후 새 Pod가 자동으로 생성됩니다.

### 재시작 후 확인

```bash
# Pod 상태 확인
kubectl get pods -n dev -l app=h-cms

# Pod 로그 확인
kubectl logs -n dev -l app=h-cms --tail=50 -f
```

**예상:** 새 Pod가 `Running` / `READY 1/1` 상태이고, 애플리케이션이 정상적으로 시작됩니다.

---

## (선택) Ingress로 외부 노출

클러스터에 Ingress Controller(예: NGINX Ingress)가 설치되어 있다면, Ingress 리소스로 서비스를 노출할 수 있습니다.

```yaml
# ingress.yaml (예시)
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
    name: h-cms
    namespace: dev
spec:
    ingressClassName: nginx
    rules:
        - host: h-cms.example.com
          http:
              paths:
                  - path: /
                    pathType: Prefix
                    backend:
                        service:
                            name: h-cms
                            port:
                                number: 80
```

```bash
kubectl apply -f ingress.yaml
```

---

## 재배포 절차 (InvalidImageName / ImagePullBackOff 해결)

Pod가 `InvalidImageName` 또는 `ImagePullBackOff`일 때 아래 순서로 재배포합니다.

### 1. Registry IP 확인 및 이미지 주소 확인

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo $SERVER_IP:5000/h-cms:latest
```

### 2. 이미지 재빌드 및 Registry 푸시

```bash
cd ~/tomcat-war-deploy/h-cms
docker build -t $SERVER_IP:5000/h-cms:latest .
docker push $SERVER_IP:5000/h-cms:latest
```

### 3. Deployment 이미지 주소 수정 후 재적용

매니페스트의 `image`가 `<REGISTRY_IP>`로 되어 있으면 실제 IP로 바꾼 뒤 적용합니다.

```bash
cd ~/tomcat-war-deploy/h-cms
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 수동 수정 후:

```bash
kubectl apply -f deployment.yaml
```

### 4. 기존 Pod 삭제 후 새 Pod 생성 (재배포)

```bash
kubectl delete pods -n dev -l app=h-cms
```

### 5. 상태 확인

```bash
kubectl get pods -n dev -l app=h-cms
```

**예상:** 새 Pod가 생성되고 `Running` / `READY 1/1`로 전환됩니다.

이후에도 실패하면 `kubectl describe pod -n dev -l app=h-cms`로 Events를 확인하고, registry-secret 및 이미지 주소를 점검합니다.

---

## 요약

| 단계 | 내용                                 |
| ---- | ------------------------------------ |
| 1    | WAR 및 프로젝트 디렉터리 준비, 설정 디렉터리(conf) 준비(선택) |
| 2    | Tomcat + WAR Dockerfile 작성         |
| 3    | 이미지 빌드 후 Private Registry push |
| 4    | 네임스페이스·imagePullSecrets 생성   |
| 5    | Deployment·Service 매니페스트 적용(설정 볼륨 hostPath 포함) |
| 6    | Pod/Service/로그·접근 확인           |

- **기존 기능 유지:** 01·02번 문서로 구성한 클러스터·Registry는 그대로 두고, WAR 앱만 추가 배포하는 형태입니다.
- **Jenkins 연동:** WAR 빌드 → 이미지 빌드·푸시 → Kubernetes 배포까지 한 번에 하려면 08번 문서를 참고하세요. Argo CD(05번)로 배포하려면 이미지 태그를 Git에 반영하면 됩니다.
