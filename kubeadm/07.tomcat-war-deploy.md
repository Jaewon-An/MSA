# Tomcat + WAR Kubernetes 배포 가이드 (kubeadm 환경)

01·02번 문서로 구성한 kubeadm 단일 노드 클러스터에 **Tomcat 기반 WAR 애플리케이션**을 배포하는 가이드입니다. WAR를 포함한 Docker 이미지를 빌드하고, Private Registry에 푸시한 뒤 Kubernetes Deployment·Service로 실행합니다.

---

## 사전 요구사항

- 01번 문서 완료: Kubernetes 단일 노드 동작 중 (`kubectl get nodes` 정상)
- 02번 문서 완료(권장): Private Docker Registry 동작 중 — 이미지 push/pull용
- WAR 파일: 빌드된 단일 WAR(로컬 또는 Jenkins 등 CI 산출물)
- 배포 수행 환경: `kubectl` 설정 완료, Registry 사용 시 Docker 로그인 또는 imagePullSecrets 준비

---

## 설치 전 확인

### 클러스터 및 kubectl
```bash
kubectl get nodes
kubectl get pods -A
```
노드가 `Ready` 상태여야 합니다.

### Registry 사용 시 (02번 문서 기준)
Private Registry를 쓰는 경우, 이미지 push를 할 머신에서 Docker 로그인이 되어 있어야 합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
docker login $SERVER_IP:5000
# Username / Password: 02번 문서에서 설정한 값
```

**예상:** `Login Succeeded`

---

## 1단계: WAR 파일 및 프로젝트 디렉터리 준비

배포할 WAR 파일을 넣을 디렉터리를 만들고, WAR를 복사합니다. (Jenkins에서 빌드한 경우 해당 경로에서 복사하거나, 빌드 산출물 경로를 아래 경로로 맞춥니다.)

```bash
# 예: 애플리케이션명 h-cms
APP_NAME=h-cms
mkdir -p ~/tomcat-war-deploy/$APP_NAME
cd ~/tomcat-war-deploy/$APP_NAME

# WAR 파일 복사 (실제 경로는 환경에 맞게 변경)
cp /path/to/your/app.war ./app.war
ls -la app.war
```

**예상:** `app.war` 파일이 존재합니다.

> **Jenkins 파이프라인에서 WAR 빌드 시:** Gradle `war` 태스크 또는 Maven `package` 산출물 경로를 위 `APP_NAME` 디렉터리로 복사하거나, 빌드 Job의 워크스페이스 경로를 기준으로 Dockerfile에서 `COPY` 경로를 맞추면 됩니다.

---

## 2단계: Dockerfile 작성

Tomcat 공식 이미지를 사용하고, WAR를 `webapps`에 넣어 루트 컨텍스트(`/`)로 서비스하는 예시입니다.

**파일:** `~/tomcat-war-deploy/$APP_NAME/Dockerfile`

```dockerfile
# Tomcat 9 + JDK 8 (Servlet 4.0 / Java EE 8). Jakarta EE 9+ WAR는 tomcat:10.1-jre17 등으로 변경
FROM tomcat:9-jdk8

# WAR 배치: 루트 컨텍스트(/)로 서비스하려면 ROOT.war로 복사
COPY app.war /usr/local/tomcat/webapps/ROOT.war

EXPOSE 8080
```

- **Jakarta EE 9+ / Servlet 5+ WAR**인 경우 첫 줄을 `FROM tomcat:10.1-jre17` 등으로 변경합니다.
- **컨텍스트 경로**를 `/h-cms`처럼 쓰려면 `COPY app.war /usr/local/tomcat/webapps/h-cms.war` 로 두고, 서비스 접근 시 `/h-cms`으로 호출하면 됩니다.

---

## 3단계: 이미지 빌드 및 Registry 푸시

같은 디렉터리에 `app.war`와 `Dockerfile`이 있다고 가정합니다.

```bash
cd ~/tomcat-war-deploy/$APP_NAME
SERVER_IP=$(hostname -I | awk '{print $1}')
IMAGE=$SERVER_IP:5000/$APP_NAME:latest

docker build -t $IMAGE .
docker push $IMAGE
```

**예상:** 빌드 성공 후 `docker push`로 레지스트리에 이미지가 등록됩니다.

---

## 4단계: 네임스페이스 및 imagePullSecrets (Private Registry 사용 시)

Kubernetes에서 Private Registry 이미지를 pull하려면 시크릿이 필요합니다.

```bash
# 네임스페이스 생성 (예: dev)
NAMESPACE=dev
kubectl create namespace $NAMESPACE

# Registry 로그인 정보로 시크릿 생성 (02번 문서의 admin / admin123 등)
kubectl create secret docker-registry registry-secret \
  --docker-server=$SERVER_IP:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n $NAMESPACE
```

**예상:** `secret/registry-secret created`

---

## 5단계: Deployment·Service 매니페스트 작성 및 적용

### 5-1. Deployment

**파일:** `~/tomcat-war-deploy/$APP_NAME/deployment.yaml`

아래는 `APP_NAME=h-cms`, `IMAGE`가 `$SERVER_IP:5000/h-cms:latest`라고 가정한 예시입니다. `NAMESPACE=dev`를 사용합니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: h-cms
  namespace: dev
  labels:
    app: h-cms
spec:
  replicas: 1
  selector:
    matchLabels:
      app: h-cms
  template:
    metadata:
      labels:
        app: h-cms
    spec:
      imagePullSecrets:
        - name: registry-secret
      containers:
        - name: tomcat
          image: "<REGISTRY_IP>:5000/h-cms:latest"
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: h-cms
  namespace: dev
spec:
  selector:
    app: h-cms
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP
```

**적용 전:** `image`의 `<REGISTRY_IP>`를 **실제 IP 또는 호스트명**으로 반드시 바꿉니다. 그대로 두면 `InvalidImageName`이 발생합니다.

```bash
# 변수로 치환하여 적용하는 예 (동일 셸에서 SERVER_IP 설정 후 실행)
SERVER_IP=$(hostname -I | awk '{print $1}')
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 편집기로 `image` 값을 `192.168.x.x:5000/h-cms:latest` 형태로 수정한 뒤:

```bash
kubectl apply -f deployment.yaml
```

**예상:** `deployment.apps/h-cms created`, `service/h-cms created`

---

## 6단계: 배포 확인

### Pod·Service 상태
```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

**예상:** Pod가 `Running`, Service가 `ClusterIP`로 생성됩니다.

### 로그 확인
```bash
kubectl logs -n dev -l app=h-cms --tail=50 -f
```

### 클러스터 내부에서 접근 테스트 (curl)
```bash
kubectl run curl --rm -it --restart=Never --image=curlimages/curl -n dev -- curl -s -o /dev/null -w "%{http_code}" http://h-cms.dev.svc.cluster.local:80/
```

**예상:** `200` 등 정상 응답 코드.

### 노드에서 포트 포워드로 브라우저 접속 (선택)
```bash
kubectl port-forward -n dev svc/h-cms 8080:80
```
이후 브라우저에서 `http://localhost:8080` 접속하여 WAR 애플리케이션 동작을 확인합니다.

---

## (선택) Ingress로 외부 노출

클러스터에 Ingress Controller(예: NGINX Ingress)가 설치되어 있다면, Ingress 리소스로 서비스를 노출할 수 있습니다.

```yaml
# ingress.yaml (예시)
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: h-cms
  namespace: dev
spec:
  ingressClassName: nginx
  rules:
    - host: h-cms.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: h-cms
                port:
                  number: 80
```

```bash
kubectl apply -f ingress.yaml
```

---

## 트러블슈팅: InvalidImageName / ImagePullBackOff

### InvalidImageName
- **원인:** `image` 필드에 `<REGISTRY_IP>`가 그대로 들어가 있거나, 이미지 이름에 허용되지 않은 문자가 있는 경우.
- **조치:**
  1. 실제 사용할 이미지 이름 확인:
     ```bash
     SERVER_IP=$(hostname -I | awk '{print $1}')
     echo $SERVER_IP:5000/h-cms:latest
     ```
  2. Deployment의 `image`를 위와 같은 형태로 수정 후 재적용:
     ```bash
     kubectl edit deployment h-cms -n dev
     # image: 192.168.x.x:5000/h-cms:latest 처럼 실제 주소로 저장
     ```
  3. 또는 매니페스트에서 치환 후 적용:
     ```bash
     sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
     ```

### ImagePullBackOff
- **원인:** 이미지가 Registry에 없거나, Registry 주소/인증이 잘못된 경우.
- **조치:**
  1. 이미지가 Registry에 있는지 확인 (빌드한 머신에서):
     ```bash
     SERVER_IP=$(hostname -I | awk '{print $1}')
     docker pull $SERVER_IP:5000/h-cms:latest
     ```
  2. 없으면 3단계에서 다시 빌드·푸시:
     ```bash
     cd ~/tomcat-war-deploy/h-cms
     docker build -t $SERVER_IP:5000/h-cms:latest .
     docker push $SERVER_IP:5000/h-cms:latest
     ```
  3. `dev` 네임스페이스에 `registry-secret`이 있는지 확인:
     ```bash
     kubectl get secret registry-secret -n dev
     ```
  4. 없거나 잘못됐으면 4단계대로 시크릿 재생성 후 Pod 재시작:
     ```bash
     kubectl delete secret registry-secret -n dev
     kubectl create secret docker-registry registry-secret \
       --docker-server=$SERVER_IP:5000 \
       --docker-username=admin \
       --docker-password=admin123 \
       -n dev
     kubectl delete pods -n dev -l app=h-cms
     ```
  5. 상세 원인 확인:
     ```bash
     kubectl describe pod -n dev -l app=h-cms
     ```
     `Events`의 `Failed` 메시지를 확인합니다.

---

## 재배포 절차 (InvalidImageName / ImagePullBackOff 해결)

Pod가 `InvalidImageName` 또는 `ImagePullBackOff`일 때 아래 순서로 재배포합니다.

### 1. Registry IP 확인 및 이미지 주소 확인
```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo $SERVER_IP:5000/h-cms:latest
```

### 2. 이미지 재빌드 및 Registry 푸시
```bash
cd ~/tomcat-war-deploy/h-cms
docker build -t $SERVER_IP:5000/h-cms:latest .
docker push $SERVER_IP:5000/h-cms:latest
```

### 3. Deployment 이미지 주소 수정 후 재적용
매니페스트의 `image`가 `<REGISTRY_IP>`로 되어 있으면 실제 IP로 바꾼 뒤 적용합니다.

```bash
cd ~/tomcat-war-deploy/h-cms
sed "s/<REGISTRY_IP>/$SERVER_IP/g" deployment.yaml | kubectl apply -f -
```

또는 수동 수정 후:
```bash
kubectl apply -f deployment.yaml
```

### 4. 기존 Pod 삭제 후 새 Pod 생성 (재배포)
```bash
kubectl delete pods -n dev -l app=h-cms
```

### 5. 상태 확인
```bash
kubectl get pods -n dev -l app=h-cms
```
**예상:** 새 Pod가 생성되고 `Running` / `READY 1/1`로 전환됩니다.

이후에도 실패하면 `kubectl describe pod -n dev -l app=h-cms`로 Events를 확인하고, 위 **트러블슈팅**의 ImagePullBackOff 조치(registry-secret 확인 등)를 진행합니다.

---

## 요약

| 단계 | 내용 |
|------|------|
| 1 | WAR 및 프로젝트 디렉터리 준비 |
| 2 | Tomcat + WAR Dockerfile 작성 |
| 3 | 이미지 빌드 후 Private Registry push |
| 4 | 네임스페이스·imagePullSecrets 생성 |
| 5 | Deployment·Service 매니페스트 적용 |
| 6 | Pod/Service/로그·접근 확인 |

- **기존 기능 유지:** 01·02번 문서로 구성한 클러스터·Registry는 그대로 두고, WAR 앱만 추가 배포하는 형태입니다.
- **Jenkins 연동:** 04번 문서의 파이프라인에서 WAR 빌드 → 위 Dockerfile로 이미지 빌드 → 동일 Registry push → `kubectl apply` 또는 Argo CD(05번)로 배포하도록 확장할 수 있습니다.
