# Jenkins 빌드 이미지를 Argo CD로 Kubernetes Pod 배포 가이드

08번(Jenkins Tomcat WAR 빌드·이미지 푸시)에서 생성한 Docker 이미지를 **Argo CD**(05번)로 Kubernetes에 Pod로 배포하는 방법을 설명합니다. Jenkins는 이미지 빌드·푸시까지 수행하고, 배포는 Git 저장소의 매니페스트를 Argo CD가 동기화하여 수행합니다.

---

## 목차

1. [개요 및 배포 흐름](#개요-및-배포-흐름)
2. [사전 요구사항](#사전-요구사항)
3. [1단계: 배포용 Git 저장소 및 매니페스트 준비](#1단계-배포용-git-저장소-및-매니페스트-준비)
4. [2단계: Argo CD 설치 및 저장소 연동](#2단계-argo-cd-설치-및-저장소-연동)
5. [3단계: Argo CD Application 생성](#3단계-argo-cd-application-생성)
6. [4단계: Jenkins 파이프라인에서 이미지 푸시 후 Git 반영](#4단계-jenkins-파이프라인에서-이미지-푸시-후-git-반영)
7. [5단계: 동기화 및 Pod 배포 확인](#5단계-동기화-및-pod-배포-확인)
8. [트러블슈팅 및 요약](#트러블슈팅-및-요약)

---

## 개요 및 배포 흐름

### 흐름도

```
[앱 Git] → Jenkins (WAR 빌드 → Docker 이미지 빌드 → Registry 푸시)
                ↓
[배포 Git] ← Jenkins (이미지 태그 반영 후 커밋·푸시)  ← 선택
                ↓
         Argo CD (Git 폴링 → 매니페스트 동기화 → Kubernetes Pod 배포)
```

- **08번**: Jenkins가 WAR 빌드 후 이미지를 `172.16.0.194:5000` Registry에 푸시합니다.
- **배포 저장소**: Deployment/Service 등 Kubernetes 매니페스트가 있는 Git 저장소입니다. 앱 소스와 같은 저장소의 `k8s/` 경로를 쓸 수도 있고, 배포 전용 저장소를 쓸 수도 있습니다.
- **05번 Argo CD**: 해당 Git 저장소의 매니페스트를 보고 클러스터에 배포(Pod 생성·갱신)합니다.

### 이 가이드에서 다루는 내용

- 배포용 매니페스트(이미지 주소: `172.16.0.194:5000/h-cms:<태그>`)를 Git에 두고 Argo CD Application으로 연결
- Jenkins는 이미지 푸시 후, 배포 저장소의 이미지 태그만 갱신해 푸시하면 Argo CD가 자동 동기화하여 Pod로 배포

---

## 사전 요구사항

| 항목 | 참고 문서 | 설명 |
|------|-----------|------|
| Kubernetes 클러스터 | 01번 | `kubectl get nodes` 정상 |
| Private Docker Registry | 02번 | 이미지 push/pull (예: 172.16.0.194:5000) |
| Jenkins (WAR 빌드·이미지 푸시) | 04번, 08번 | 08번까지 진행해 이미지가 Registry에 푸시되는 상태 |
| Argo CD | 05번 | Git 기반 CD, Pod로 클러스터 내 실행 |
| Tomcat WAR 배포 구조 | 07번 | Deployment·Service·imagePullSecrets 구조 참고 |

- **Registry 주소**: `172.16.0.194:5000` (문서 예시)
- **애플리케이션명**: 07번과 동일 (예: `h-cms`), 네임스페이스 `dev`

---

## 1단계: 배포용 Git 저장소 및 매니페스트 준비

### 1-1. 저장소 구조 (옵션 A: 앱 저장소 내 k8s/)

앱 소스와 같은 Git 저장소를 쓰는 경우:

```
앱 저장소 루트/
  Jenkinsfile
  Dockerfile
  k8s/
    deployment.yaml   # Deployment + Service (아래 예시)
```

### 1-2. 저장소 구조 (옵션 B: 배포 전용 저장소)

배포 전용 저장소를 쓰는 경우:

```
배포 저장소 루트/
  dev/
    deployment.yaml   # 또는 overlays/dev 등
```

### 1-3. Deployment·Service 매니페스트 예시

07번 5단계의 Deployment/Service를 기준으로, **image**만 Registry 주소와 태그로 채웁니다. Argo CD가 이 파일(들)을 적용합니다.

```yaml
# k8s/deployment.yaml (또는 배포 저장소의 dev/deployment.yaml)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: h-cms
  namespace: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: h-cms
  template:
    metadata:
      labels:
        app: h-cms
    spec:
      imagePullSecrets:
        - name: registry-secret
      containers:
        - name: hcms
          image: 172.16.0.194:5000/h-cms:latest   # Jenkins 빌드 이미지 (태그는 Jenkins에서 갱신 가능)
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
          # env, volumeMounts, resources, probes 등은 07번 5단계 참고
          resources:
            requests: { memory: '256Mi', cpu: '100m' }
            limits:   { memory: '512Mi', cpu: '500m' }
---
apiVersion: v1
kind: Service
metadata:
  name: h-cms
  namespace: dev
spec:
  selector:
    app: h-cms
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP
```

- **image**: `172.16.0.194:5000/h-cms:latest` 또는 `172.16.0.194:5000/h-cms:<BUILD_NUMBER>` 형태. Jenkins에서 이 값을 갱신한 뒤 Git에 푸시하면 Argo CD가 동기화합니다.
- **imagePullSecrets**: `dev` 네임스페이스에 미리 만들어 두어야 합니다(1-4 참고).

### 1-4. 네임스페이스 및 imagePullSecrets 사전 생성

Argo CD는 매니페스트에 있는 리소스만 배포합니다. `dev` 네임스페이스와 Private Registry 인증용 시크릿은 **한 번** `kubectl`로 생성합니다.

```bash
kubectl create namespace dev
kubectl create secret docker-registry registry-secret \
  --docker-server=172.16.0.194:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n dev
```

### 1-5. 매니페스트를 Git에 푸시

- `k8s/deployment.yaml`(또는 배포 전용 저장소의 경로)을 커밋·푸시합니다.
- 이후 이미지 태그만 바꿔서 푸시하면 Argo CD가 그 변경을 반영합니다.

---

## 2단계: Argo CD 설치 및 저장소 연동

### 2-1. Argo CD 설치 (미설치 시)

**05번 문서** [Argo CD 기반 CD 배포 가이드](05.argocd-install.md)에 따라 Argo CD를 설치합니다.

```bash
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl get pods -n argocd -w   # 모두 Running 될 때까지 대기
```

### 2-2. Argo CD에 Git 저장소 등록

배포용 매니페스트가 있는 Git 저장소를 Argo CD에 등록합니다.

- **UI**: Argo CD 웹 (https://172.16.0.194:\<NodePort\>) → **Settings** → **Repositories** → **Connect Repo**  
  - Repository URL, 인증(Username/Password 또는 SSH) 입력
- **CLI**:

```bash
argocd repo add https://gitlab.com/your-group/your-deploy-repo.git \
  --username <user> \
  --password <token-or-password>
```

연결 상태가 **Successful**인지 확인합니다.

---

## 3단계: Argo CD Application 생성

Argo CD Application은 "어떤 Git 저장소의 어떤 경로를 어떤 네임스페이스에 배포할지"를 정의합니다.

### 3-1. Application YAML 예시 (Plain YAML 매니페스트)

배포 매니페스트가 `k8s/` 경로에 있는 경우:

```yaml
# application-h-cms.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: h-cms
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://gitlab.com/your-group/your-repo.git   # 앱 저장소 또는 배포 전용 저장소
    path: k8s
    targetRevision: HEAD
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

- **path**: 저장소 내 매니페스트 경로 (예: `k8s`, `dev`, `overlays/dev` 등).
- **destination.namespace**: `dev` (07번·08번과 동일).
- **syncPolicy.automated**: Git 변경 시 자동 동기화로 Pod 배포·갱신.

### 3-2. Application 적용

```bash
kubectl apply -f application-h-cms.yaml
```

### 3-3. UI에서 확인

- Argo CD 웹 → **Applications** → `h-cms` 선택
- Sync Status가 **Synced**, Health가 **Healthy**인지 확인.  
  최초 적용 시 Pod가 생성되고, `kubectl get pods -n dev -l app=h-cms`로 확인할 수 있습니다.

---

## 4단계: Jenkins 파이프라인에서 이미지 푸시 후 Git 반영

08번 Jenkins 파이프라인에서 **이미지 빌드·푸시**까지 한 뒤, **배포용 Git 저장소의 이미지 태그를 갱신해 푸시**하면 Argo CD가 자동으로 동기화합니다.

### 4-1. 흐름 요약

1. Jenkins: WAR 빌드 → Docker 이미지 빌드 → `172.16.0.194:5000/h-cms:<BUILD_NUMBER>` 푸시 (08번과 동일).
2. Jenkins: 배포 저장소(또는 앱 저장소의 `k8s/`)를 체크아웃하고, `deployment.yaml`의 `image`를 새 태그로 수정 후 커밋·푸시.
3. Argo CD: Git 변경 감지 → 자동 Sync → Kubernetes에 Deployment 반영 → Pod 재배포.

### 4-2. Jenkinsfile 예시 (이미지 푸시 + 배포 저장소 이미지 태그 푸시)

배포 전용 저장소를 별도로 두고, 해당 저장소의 `k8s/deployment.yaml`만 수정하는 예시입니다.

```groovy
pipeline {
  agent any
  tools { maven 'M3' }
  environment {
    REGISTRY = '172.16.0.194:5000'
    APP_NAME = 'h-cms'
    NAMESPACE = 'dev'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
    DEPLOY_REPO = 'https://gitlab.com/your-group/your-deploy-repo.git'   // 배포용 저장소
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp humanframe.web/target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
    stage('Update Deploy Repo & Push') {
      steps {
        sh """
          git clone --depth 1 ${DEPLOY_REPO} deploy-repo
          cd deploy-repo
          sed -i 's|172.16.0.194:5000/${APP_NAME}:.*|172.16.0.194:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' k8s/deployment.yaml
          git config user.email 'jenkins@example.com'
          git config user.name 'Jenkins'
          git add k8s/deployment.yaml
          git commit -m "Update image to ${env.BUILD_NUMBER}" || true
          git push
        """
      }
    }
  }
  post {
    always { deleteDir() }
  }
}
```

- **DEPLOY_REPO**: 배포용 Git 저장소 URL. 배포 저장소용 Credentials가 필요하면 `git clone`에 인증을 붙여 사용합니다.
- **앱 저장소와 같은 저장소**를 쓰는 경우: `checkout scm`으로 이미 그 저장소가 있으므로, `k8s/deployment.yaml`만 `sed`로 수정한 뒤 커밋·푸시하는 단계를 추가하면 됩니다.

이렇게 푸시된 변경을 Argo CD가 감지해 자동으로 Sync하고, Kubernetes에 Pod가 배포됩니다.

---

## 5단계: 동기화 및 Pod 배포 확인

### 5-1. Argo CD 동기화 상태

```bash
argocd app list
argocd app get h-cms
```

수동 Sync가 필요하면:

```bash
argocd app sync h-cms
```

### 5-2. Pod·Service 확인

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

### 5-3. 애플리케이션 접근 (07번과 동일)

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
# 브라우저: http://localhost:8080
```

---

## 트러블슈팅 및 요약

### 자주 나오는 현상

| 현상 | 원인 | 조치 |
|------|------|------|
| Argo CD Application이 OutOfSync | Git과 클러스터 상태 불일치 | `argocd app sync h-cms` 또는 UI에서 Sync |
| ImagePullBackOff | 레지스트리 인증 또는 이미지 주소 오류 | `dev` 네임스페이스의 `registry-secret`, 이미지 태그 확인 |
| Jenkins에서 배포 저장소 push 실패 | Git 인증 없음 또는 URL 오류 | 배포 저장소용 Credentials 등록, DEPLOY_REPO 확인 |

### 문서 요약

| 단계 | 내용 |
|------|------|
| 1 | 배포용 Git 저장소 및 k8s 매니페스트 준비 (image: 172.16.0.194:5000/h-cms:태그), namespace·imagePullSecrets 사전 생성 |
| 2 | Argo CD 설치(05번), 배포용 Git 저장소 Argo CD에 등록 |
| 3 | Argo CD Application 생성 (source: repo + path, destination: dev), 적용 |
| 4 | Jenkins: 이미지 푸시 후 배포 저장소의 이미지 태그 갱신·푸시 → Argo CD 자동 Sync |
| 5 | argocd/kubectl로 동기화·Pod·Service 확인 |

- **08번 유지**: Jenkins의 WAR 빌드·이미지 푸시 흐름은 08번 문서대로 유지하고, 배포만 Argo CD로 이전한 구조입니다.
- **05번 Argo CD**: Git 저장소의 매니페스트를 Kubernetes에 반영해 Pod로 배포하는 역할만 추가로 사용합니다.
