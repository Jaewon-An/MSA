# Jenkins 기반 CI 빌드 가이드 (Linux 직접 설치)

Kubernetes Pod가 아닌 **Linux 서버에 Jenkins를 직접 설치**하고, 소스 코드 빌드·테스트·이미지 빌드 파이프라인을 구성하는 가이드입니다. OpenJDK 21 기반이며, 01번 문서의 kubeadm 클러스터와 연동할 수 있습니다.

---

## 목차

1. [기존 Jenkins Pod 완전 삭제 (Kubernetes 사용 중이었던 경우)](#기존-jenkins-pod-완전-삭제-kubernetes-사용-중이었던-경우)
2. [사전 요구사항](#사전-요구사항)
3. [1단계: Java 21 설치](#1단계-java-21-설치)
4. [2단계: Jenkins 저장소 추가 및 설치](#2단계-jenkins-저장소-추가-및-설치)
5. [3단계: Jenkins 서비스 설정](#3단계-jenkins-서비스-설정)
6. [4단계: Jenkins 서비스 시작 및 방화벽](#4단계-jenkins-서비스-시작-및-방화벽)
7. [5단계: 초기 비밀번호 확인 및 웹 접속](#5단계-초기-비밀번호-확인-및-웹-접속)
8. [6단계: Jenkins 기본 설정 및 플러그인](#6단계-jenkins-기본-설정-및-플러그인)
9. [7단계: kubectl / Docker / Maven (선택)](#7단계-kubectl--docker--maven-선택)
10. [8단계: 파이프라인 Job 예시](#8단계-파이프라인-job-예시)
11. [9단계: 동작 확인](#9단계-동작-확인)

---

## 기존 Jenkins Pod 완전 삭제 (Kubernetes 사용 중이었던 경우)

이전에 Kubernetes에 Jenkins를 Pod로 배포했다면, Linux 직접 설치로 전환하기 전에 아래 순서로 **기존 Jenkins 리소스를 완전히 삭제**합니다.

### 삭제 순서

```bash
# 1. jenkins 네임스페이스의 Deployment, Service, PVC 등 삭제
kubectl delete deployment jenkins -n jenkins --ignore-not-found=true
kubectl delete service jenkins -n jenkins --ignore-not-found=true
kubectl delete pvc jenkins-pvc -n jenkins --ignore-not-found=true

# 2. 에이전트용으로 만든 Role / RoleBinding 삭제 (08 문서 등에서 적용한 경우)
kubectl delete role jenkins-agent-role -n jenkins --ignore-not-found=true
kubectl delete rolebinding jenkins-agent-rolebinding -n jenkins --ignore-not-found=true

# 3. 네임스페이스 내 모든 리소스 확인 후 정리
kubectl get all,pvc -n jenkins
# 남은 리소스가 있으면 개별 삭제
# kubectl delete <resource-type> <name> -n jenkins

# 4. jenkins 네임스페이스 삭제 (내부 리소스가 모두 삭제된 뒤)
kubectl delete namespace jenkins

# 5. (선택) 수동으로 만든 PV가 있다면 삭제
kubectl get pv | grep jenkins
# kubectl delete pv jenkins-pv   # 해당 PV 이름으로 삭제
```

### Helm으로 설치했던 경우

```bash
helm uninstall jenkins -n jenkins
kubectl delete pvc -n jenkins --all   # PVC가 "Released"로 남을 수 있음
kubectl delete namespace jenkins
```

### 삭제 확인

```bash
kubectl get namespace jenkins   # Error: namespaces "jenkins" not found
kubectl get pv | grep jenkins   # (해당 PV 없음)
```

이후 동일 서버 또는 다른 Linux 서버에서 본 문서의 **Linux 직접 설치** 단계를 진행하면 됩니다.

---

## 사전 요구사항

- **Linux 서버**: RHEL 9 / Rocky Linux 9 / CentOS Stream 9 등 (dnf 사용)
- **관리자 권한**: `sudo` 가능
- Git 저장소 접근 가능 (GitLab 등)
- 컨테이너 레지스트리 접근 (Docker Hub, Private Registry 등)
- (선택) Kubernetes 클러스터 연동 시 `kubectl` 및 kubeconfig

---

## 1단계: Java 21 설치

```bash
# 1. Java 21 설치
sudo dnf install -y java-21-openjdk java-21-openjdk-devel

# 2. Java 버전 확인
java -version

# 3. 설치된 Java 목록 확인
sudo alternatives --config java
```

**예상 출력:**

```
openjdk version "21.0.x" ...
OpenJDK Runtime Environment ...
```

Java 21이 기본이 아니면 해당 번호를 선택합니다.

```bash
# 4. JAVA_HOME 설정
echo 'export JAVA_HOME=/usr/lib/jvm/java-21-openjdk' | sudo tee /etc/profile.d/java21.sh
echo 'export PATH=$JAVA_HOME/bin:$PATH' | sudo tee -a /etc/profile.d/java21.sh
source /etc/profile.d/java21.sh

# 5. 확인
echo $JAVA_HOME
java -version
```

---

## 2단계: Jenkins 저장소 추가 및 설치

```bash
# 1. Jenkins 저장소 추가
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo

# 2. GPG 키 가져오기
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key

# 3. Jenkins 설치
sudo dnf install -y jenkins

# 4. 버전 확인
rpm -q jenkins
```

**예상:** `jenkins-2.xxx.x-1.1.noarch` 등으로 표시됩니다.

---

## 3단계: Jenkins 서비스 설정

기본 JENKINS_HOME(`/var/lib/jenkins`)을 사용합니다. Java 21을 사용하도록 systemd override만 추가합니다.

```bash
# 1. Java 21 사용하도록 override 추가
sudo mkdir -p /etc/systemd/system/jenkins.service.d
sudo tee /etc/systemd/system/jenkins.service.d/override.conf > /dev/null <<EOF
[Service]
Environment="JAVA_HOME=/usr/lib/jvm/java-21-openjdk"
Environment="JENKINS_JAVA_CMD=/usr/lib/jvm/java-21-openjdk/bin/java"
EOF

# 2. systemd 재로드
sudo systemctl daemon-reload

# 3. 설정 확인
sudo systemctl cat jenkins.service | grep -E "JENKINS_HOME|JAVA"
```

**예상 출력:**

```
Environment="JENKINS_HOME=/var/lib/jenkins"
Environment="JAVA_HOME=/usr/lib/jvm/java-21-openjdk"
Environment="JENKINS_JAVA_CMD=/usr/lib/jvm/java-21-openjdk/bin/java"
```

---

## 4단계: Jenkins 서비스 시작 및 방화벽

```bash
# 1. 서비스 시작 및 부팅 시 자동 시작
sudo systemctl start jenkins
sudo systemctl enable jenkins

# 2. 상태 확인 (기동에 1~2분 걸릴 수 있음)
sleep 30
sudo systemctl status jenkins
```

**예상:** `Active: active (running)` 이어야 합니다.

```bash
# 3. 방화벽에서 8080 포트 허용
sudo firewall-cmd --permanent --add-port=8080/tcp
sudo firewall-cmd --reload
sudo firewall-cmd --list-ports | grep 8080
```

실패 시 로그 확인:

```bash
sudo journalctl -u jenkins -n 50 --no-pager
sudo ss -tulpn | grep 8080
```

---

## 5단계: 초기 비밀번호 확인 및 웹 접속

```bash
# Jenkins가 완전히 기동할 때까지 대기
until sudo test -f /var/lib/jenkins/secrets/initialAdminPassword; do
  echo "대기 중..."
  sleep 5
done

echo "=== Jenkins 초기 관리자 비밀번호 ==="
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
echo "================================"
```

**접속 URL:** `http://<서버IP>:8080`

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "Jenkins URL: http://$SERVER_IP:8080"
```

웹에서 초기 설정:

1. **Unlock Jenkins**: 위에서 확인한 비밀번호 입력 후 Continue
2. **Customize Jenkins**: Install suggested plugins
3. **Create First Admin User**: 관리자 계정 생성 (예: admin / 비밀번호)
4. **Instance Configuration**: Jenkins URL 확인 후 Save and Finish
5. **Start using Jenkins** 클릭

---

## 6단계: Jenkins 기본 설정 및 플러그인

### 6-1. 보안 설정 (권장)

- **Manage Jenkins** → **Security** → **Configure Global Security**
- **Security Realm**: Jenkins' own user database
- **Authorization**: Logged-in users can do anything 또는 Matrix-based security

### 6-2. 필수 플러그인

**Manage Jenkins** → **Plugins** → **Available plugins**에서 설치:

| 플러그인 | 용도 |
|---------|------|
| Pipeline | Pipeline Job, Jenkinsfile |
| Git | Git 저장소 체크아웃 |
| Docker Pipeline | docker.build(), withRegistry() |
| Credentials | 저장소·레지스트리 인증 |
| Kubernetes | (선택) Kubernetes Cloud로 Agent Pod 사용 시 |

설치 후 **Restart Jenkins when installation is complete** 선택 후 재시작합니다.

### 6-3. Kubernetes 연동 (선택)

Jenkins를 Kubernetes 클러스터에서 에이전트 Pod를 띄우려면:

- **Manage Jenkins** → **Nodes** → **Configure Clouds** → **Kubernetes**
- Kubernetes URL: `https://<API서버주소>`
- Jenkins URL: `http://<이 서버 IP>:8080`
- Credentials: kubeconfig 또는 서비스 계정 토큰

Linux 직접 설치 시에는 **agent any** 로 같은 서버에서 빌드하는 구성이 일반적입니다.

---

## 7단계: kubectl / Docker / Maven (선택)

### 7-1. kubectl (Kubernetes 배포 시)

Jenkins에서 `kubectl apply`를 쓰려면 Jenkins 사용자에게 kubeconfig를 복사합니다.

```bash
# 클러스터 노드의 kubeconfig를 Jenkins 사용자 홈에 복사
sudo mkdir -p /var/lib/jenkins/.kube
sudo cp ~/.kube/config /var/lib/jenkins/.kube/config
sudo chown -R jenkins:jenkins /var/lib/jenkins/.kube
sudo chmod 600 /var/lib/jenkins/.kube/config

# Jenkins 사용자로 테스트
sudo -u jenkins kubectl get nodes
```

### 7-2. Docker (이미지 빌드 시)

같은 서버에서 `docker build`를 쓰는 경우:

```bash
sudo usermod -aG docker jenkins
sudo systemctl restart jenkins
# 재시작 후
sudo -u jenkins docker ps
```

### 7-3. Maven (Java 빌드 시)

```bash
sudo dnf install -y maven
mvn -version
# jenkins 사용자로 확인 시 시스템 Maven 경로 사용 (다른 사용자 경로와 혼동 방지)
sudo -u jenkins /usr/bin/mvn -version
```

Jenkins **Global Tool Configuration**에서 Maven 자동 설치를 쓰거나, 위처럼 시스템 Maven을 사용할 수 있습니다.

**jenkins로 `mvn` 실행 시 `cd: /home/... 디렉터리가 아닙니다` 오류가 나는 경우:**  
다른 사용자(예: jnet)의 Maven 스크립트나 `MAVEN_HOME`이 PATH에 섞여 있을 수 있습니다. 다음을 확인하세요.

```bash
# 시스템 Maven만 사용하는지 확인
which mvn
ls -la /usr/bin/mvn

# jenkins는 반드시 시스템 Maven 경로로 실행
sudo -u jenkins /usr/bin/mvn -version
```

Jenkins 파이프라인에서 Maven을 쓸 때는 **Global Tool Configuration**에서 Maven 자동 설치를 쓰거나, `sh '/usr/bin/mvn clean package'` 처럼 절대 경로를 지정하면 같은 오류를 피할 수 있습니다.

---

## 8단계: 파이프라인 Job 예시 (Jenkinsfile)

### 8-1. Pipeline Job 생성

- **New Item** → 이름 입력 → **Pipeline** → OK
- **Pipeline**: Definition → **Pipeline script from SCM**
- **SCM**: Git, Repository URL, Credentials, Branch 설정
- **Script Path**: `Jenkinsfile`

### 8-2. Jenkinsfile 예시 (빌드 → 테스트 → 이미지 빌드)

```groovy
pipeline {
  agent any
  environment {
    REGISTRY = 'your-registry.io'
    IMAGE_NAME = 'myapp'
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build') {
      steps {
        sh 'mvn clean package -DskipTests'
      }
    }
    stage('Test') {
      steps {
        sh 'mvn test'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${REGISTRY}/${IMAGE_NAME}:${env.BUILD_NUMBER}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${REGISTRY}/${IMAGE_NAME}:${env.BUILD_NUMBER}").push()
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
```

Linux 직접 설치 환경에서는 **agent any** 로 Jenkins 서버에서 실행됩니다. Registry 주소와 Credentials ID는 실제 환경에 맞게 수정합니다.

---

## 9단계: 동작 확인

### 9-1. 파이프라인 실행

- Job 실행 후 **Console Output**에서 단계별 성공 여부 확인
- 빌드 산출물 및 이미지 푸시 여부 확인

### 9-2. 설치 검증 (터미널)

```bash
echo "=== Java ==="
java -version 2>&1 | head -1
echo "=== Jenkins 서비스 ==="
sudo systemctl is-active jenkins
echo "=== Jenkins 홈 ==="
ls -la /var/lib/jenkins/ | head -5
echo "=== Jenkins URL ==="
echo "http://$(hostname -I | awk '{print $1}'):8080"
```

### 9-3. ArgoCD 연동 시

빌드된 이미지 태그를 Git(Helm/Kustomize)에 반영하거나, Argo CD 이미지 업데이트 정책으로 자동 반영할 수 있습니다. (05. Argo CD 배포 가이드 참고)

---

## 요약 및 참고

| 항목 | 내용 |
|------|------|
| 설치 방식 | Linux 직접 설치 (systemd, dnf) |
| JENKINS_HOME | /var/lib/jenkins (기본값) |
| 접속 URL | http://\<서버IP\>:8080 |
| 초기 비밀번호 | `sudo cat /var/lib/jenkins/secrets/initialAdminPassword` |
| agent | agent any (동일 서버에서 빌드) |

- **기존 K8s Jenkins 제거:** 문서 상단 [기존 Jenkins Pod 완전 삭제](#기존-jenkins-pod-완전-삭제-kubernetes-사용-중이었던-경우) 참고
- **문제 발생 시:** `sudo journalctl -u jenkins -f` 로 로그 확인
