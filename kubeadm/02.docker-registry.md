# Docker Registry 설치 가이드 (kubeadm 환경)

Kubernetes 클러스터(kubeadm 단일 노드)와 동일한 서버 또는 접근 가능한 서버에 Private Docker Registry를 구축하는 가이드입니다. 01번 문서의 Rocky Linux + containerd 환경을 기준으로 하며, Jenkins(04번, Linux 직접 설치)에서 빌드한 이미지를 push하고 클러스터에서 pull할 때 사용할 수 있습니다.

---

## 사전 요구사항

- 01번 문서 완료: Kubernetes 단일 노드 동작 중 (`kubectl get nodes` 정상)
- Registry를 설치할 서버: Rocky Linux 8/9 (x86_64), root 또는 sudo 권한
- (Registry를 kubeadm 노드와 같은 서버에 둘 경우) 해당 노드에 Docker CE 설치 필요 — 컨테이너 런타임은 containerd만 사용하고, Registry 실행용으로만 Docker 사용

---

## 설치 전 확인

01번 문서 완료 상태를 전제로 합니다. 노드가 `Ready`인지 확인합니다.

```bash
kubectl get nodes
kubectl get pods -A
```

### Registry 서버에서 Docker 사용 가능 여부
kubeadm 노드에는 기본적으로 **containerd**만 있으므로, Registry를 **Docker 컨테이너**로 실행하려면 같은 서버에 Docker CE를 설치해야 합니다. (또는 별도 서버에 Docker가 이미 있는 경우 해당 서버에 Registry를 설치합니다.)

```bash
# Docker 설치 여부 확인
docker --version 2>/dev/null || echo "Docker 미설치"
```

**Docker가 없는 경우** 아래 "0단계: Docker CE 설치"를 먼저 진행합니다.

**`permission denied` (Docker 소켓 접근 거부)** 가 나오면, 현재 사용자를 `docker` 그룹에 넣은 뒤 세션을 다시 열어야 합니다.

```bash
# 현재 사용자를 docker 그룹에 추가
sudo usermod -aG docker $USER

# 적용을 위해 로그아웃 후 다시 로그인하거나, 현재 셸에서 그룹 적용
newgrp docker
```

이후 `docker ps` 등이 sudo 없이 동작하는지 확인합니다. (Compose로 Registry 실행 시에도 동일하게 적용됩니다.)

---

## 0단계: Docker CE 설치 (Registry 서버에 Docker가 없을 때)

kubeadm 노드와 **같은 서버**에 Registry를 두고 Docker가 없다면, Registry 전용으로만 Docker CE를 설치합니다. Kubernetes는 계속 containerd를 사용합니다.

### 0-1. Docker 저장소 추가 및 설치
```bash
# Docker 공식 저장소 (Rocky Linux / RHEL 계열)
sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# Docker 서비스 시작 및 활성화
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl status docker
```

**예상:** `Active: active (running)`

### 0-2. Docker와 Kubernetes(containerd) 공존
이 서버에서는 **kubelet이 사용하는 containerd**와 **Docker가 내부적으로 사용하는 containerd**가 다를 수 있습니다. `dnf install containerd.io`는 Docker 전용 containerd를 설치합니다. 기존에 01번 문서로 설치한 **시스템 containerd**(`/run/containerd/containerd.sock`)는 그대로 두고, Docker는 **Docker 데몬 전용**으로만 사용합니다.
즉, `kubelet`은 기존 containerd를, `docker run`(Registry 컨테이너)은 Docker 데몬을 사용합니다.

---

## 1단계: Registry 디렉토리 생성

### 1-1. 데이터·인증·인증서 디렉토리
```bash
sudo mkdir -p /data/docker-registry/{data,auth,certs}
sudo chown -R $USER:$USER /data/docker-registry
cd /data/docker-registry
ls -la
```

**예상 출력:**
```
drwxr-xr-x. auth
drwxr-xr-x. certs
drwxr-xr-x. data
```

---

## 2단계: Registry 인증 설정

### 2-1. htpasswd 설치 및 사용자 생성
```bash
sudo dnf install -y httpd-tools
htpasswd -Bc auth/htpasswd admin
# 비밀번호 입력: admin123 (또는 원하는 비밀번호)
cat auth/htpasswd
```

**예상:** `admin:$2y$05$...` 형태의 한 줄이 출력됩니다.

---

## 3단계: 자체 서명 인증서 생성 (개발/내부용)

### 3-1. 서버 IP 기준 인증서 생성
```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "서버 IP: $SERVER_IP"

openssl req -newkey rsa:4096 -nodes -sha256 \
  -keyout certs/domain.key -x509 -days 365 \
  -out certs/domain.crt \
  -subj "/C=KR/ST=Seoul/L=Seoul/O=MyCompany/CN=$SERVER_IP" \
  -addext "subjectAltName=IP:$SERVER_IP,DNS:localhost"
ls -lh certs/
```

**예상:** `domain.crt`, `domain.key` 파일이 생성됩니다.

---

## 4단계: 방화벽 포트 오픈

Registry는 5000/tcp를 사용합니다.

```bash
sudo firewall-cmd --permanent --add-port=5000/tcp
sudo firewall-cmd --reload
sudo firewall-cmd --list-ports
```

**예상:** `5000/tcp`가 목록에 포함됩니다.

---

## 5단계: Docker Registry 컨테이너 실행

### 5-1. Registry 컨테이너 실행
```bash
docker run -d \
  --restart=always \
  --name registry \
  -v /data/docker-registry/data:/var/lib/registry \
  -v /data/docker-registry/auth:/auth \
  -v /data/docker-registry/certs:/certs \
  -e REGISTRY_HTTP_ADDR=0.0.0.0:5000 \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
  -e REGISTRY_AUTH=htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_REALM="Registry Realm" \
  -p 5000:5000 \
  registry:2
```

### 5-1-2. (선택) Compose로 실행

동일한 구성을 Compose로 실행하려면 프로젝트 디렉터리에 `docker-compose.yml`을 만들고 실행합니다.

**파일 생성:** `/data/docker-registry/docker-compose.yml`

```yaml
services:
  registry:
    image: registry:2
    container_name: registry
    restart: always
    ports:
      - "5000:5000"
    volumes:
      - /data/docker-registry/data:/var/lib/registry
      - /data/docker-registry/auth:/auth
      - /data/docker-registry/certs:/certs
    environment:
      REGISTRY_HTTP_ADDR: 0.0.0.0:5000
      REGISTRY_HTTP_TLS_CERTIFICATE: /certs/domain.crt
      REGISTRY_HTTP_TLS_KEY: /certs/domain.key
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd
      REGISTRY_AUTH_HTPASSWD_REALM: "Registry Realm"
```

**실행:**

```bash
cd /data/docker-registry
docker compose up -d
```

**중지/제거:** `docker compose down` (볼륨 데이터는 호스트 경로에 남습니다.)

### 5-2. 실행 확인
```bash
docker ps | grep registry
```

**예상:** `registry` 컨테이너가 `0.0.0.0:5000->5000/tcp`로 떠 있습니다.

---

## 6단계: Docker 클라이언트에서 인증서 신뢰 (같은 서버에서 push/pull 시)

같은 서버에서 `docker login`, `docker push`를 할 경우 인증서를 신뢰하도록 설정합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
sudo mkdir -p /etc/docker/certs.d/$SERVER_IP:5000
sudo cp /data/docker-registry/certs/domain.crt /etc/docker/certs.d/$SERVER_IP:5000/ca.crt
sudo systemctl restart docker
docker start registry
```

---

## 7단계: containerd에서 Registry 사용 설정 (kubeadm 노드)

Kubernetes 노드(containerd)가 이 Registry에서 이미지를 pull하려면, 해당 노드에서 **CA를 신뢰**하도록 설정해야 합니다. Registry 서버와 kubeadm 노드가 **같은 서버**인 경우 아래를 그 서버에서 실행합니다.

### 7-1. certs.d 디렉토리 및 hosts.toml

containerd 1.5+ 에서는 `certs.d`를 사용합니다.

```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
REGISTRY_HOST="$SERVER_IP:5000"
sudo mkdir -p /etc/containerd/certs.d/$REGISTRY_HOST
sudo tee /etc/containerd/certs.d/$REGISTRY_HOST/hosts.toml <<EOF
server = "https://$REGISTRY_HOST"
[host."https://$REGISTRY_HOST"]
  ca = "/etc/containerd/certs.d/$REGISTRY_HOST/ca.crt"
  skip_verify = false
EOF
sudo cp /data/docker-registry/certs/domain.crt /etc/containerd/certs.d/$REGISTRY_HOST/ca.crt
```

### 7-2. containerd 설정에 config_path 추가 (없는 경우)

`/etc/containerd/config.toml`에 이미 `config_path`가 있으면 생략합니다.

```bash
# config_path 존재 여부 확인
grep -q 'config_path' /etc/containerd/config.toml && echo "이미 설정됨" || \
  echo 'config_path = "/etc/containerd/certs.d"' | sudo tee -a /etc/containerd/config.toml
```

표준 containerd 설정에서는 `config_path`가 기본일 수 있습니다. 없다면 아래 블록이 **plugins."io.containerd.grpc.v1.cri".registry** 섹션 안에 있는지 확인하고, 없으면 추가합니다.

```toml
[plugins."io.containerd.grpc.v1.cri".registry]
  config_path = "/etc/containerd/certs.d"
```

### 7-3. containerd 재시작
```bash
sudo systemctl restart containerd
sudo systemctl restart kubelet
```

**주의:** 잠시 Pod가 재시작할 수 있습니다.

---

## 8단계: Registry 로그인 및 동작 테스트

### 8-1. Docker 로그인 (Registry 서버에서)
```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
docker login $SERVER_IP:5000
# Username: admin
# Password: admin123
```

**예상:** `Login Succeeded`

### 8-2. 이미지 push 테스트
```bash
docker pull hello-world
docker tag hello-world $SERVER_IP:5000/hello-world:test
docker push $SERVER_IP:5000/hello-world:test
```

### 8-3. Registry API로 저장소 목록 확인
```bash
curl -u admin:admin123 -k https://$SERVER_IP:5000/v2/_catalog
```

**예상:** `{"repositories":["hello-world"]}`

### 8-4. Kubernetes(containerd)에서 pull 테스트

Private Registry에서 pull하려면 **imagePullSecrets**가 필요합니다. 먼저 시크릿을 만듭니다.

```bash
kubectl create namespace demo
kubectl create secret docker-registry registry-secret \
  --docker-server=$SERVER_IP:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n demo
```

테스트 Pod 실행:
```bash
kubectl run hello-registry --image=$SERVER_IP:5000/hello-world:test --restart=Never -n demo --overrides='{"spec":{"imagePullSecrets":[{"name":"registry-secret"}]}}'
kubectl get pods -n demo
kubectl delete pod hello-registry -n demo
```

**예상:** Pod가 `Running` 후 종료(Completed)되거나, `kubectl get pods`에서 정상 표시됩니다.

---

## 9단계: Jenkins(04번)와 연동

04번 문서(Linux 직접 설치)의 Jenkins 가이드에 따라 구성한 Jenkins의 Jenkinsfile에서 `REGISTRY`를 이 Registry 주소로 설정하면 됩니다.

- **Registry가 kubeadm 노드와 같은 서버인 경우:** `REGISTRY = '서버IP:5000'` (예: `172.16.0.194:5000`)
- Jenkins에서 Docker로 빌드·push하므로, **Jenkins가 실행되는 호스트**에서 해당 주소로 접근 가능해야 하고, 인증서를 신뢰하거나 `--insecure-registry`로 접근할 수 있어야 합니다.

Jenkins Credentials에 Docker Registry 계정을 등록합니다.

- Kind: **Username with password**
- ID: `registry-credentials` (Jenkinsfile의 `docker.withRegistry(..., 'registry-credentials')`와 일치)
- Username: `admin`
- Password: `admin123`

Jenkinsfile 예시:
```groovy
environment {
  REGISTRY = '172.16.0.194:5000'   // 실제 Registry 서버 IP:5000으로 변경
  IMAGE_NAME = 'myapp'
}
```

---

## 요약 및 확인 사항

| 항목 | 내용 |
|------|------|
| Registry URL | `https://172.16.0.194:5000` |
| 기본 사용자 | admin / admin123 (변경 권장) |
| 데이터 디렉토리 | `/data/docker-registry/data` |
| 인증서 | `/data/docker-registry/certs` (자체 서명, 개발/내부용) |
| containerd 설정 | `/etc/containerd/certs.d/<IP>:5000/` |

### 한 번에 확인하는 명령어
```bash
SERVER_IP=$(hostname -I | awk '{print $1}')
echo "=== Registry 컨테이너 ==="
docker ps | grep registry
echo -e "\n=== Registry 로그인 테스트 ==="
echo "admin / admin123" | docker login $SERVER_IP:5000 2>&1 | grep -i "login\|error"
echo -e "\n=== Registry 카탈로그 ==="
curl -u admin:admin123 -k https://$SERVER_IP:5000/v2/_catalog
echo -e "\n=== Registry URL ==="
echo "https://$SERVER_IP:5000"
```

---

- **다음 단계:** 04번(Linux 직접 설치) Jenkins에서 위 Registry를 `REGISTRY`로 설정해 이미지 빌드·push 후, 05번 Argo CD 등으로 배포할 수 있습니다.
