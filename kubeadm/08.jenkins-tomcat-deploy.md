# Jenkins로 Tomcat WAR Kubernetes 배포 가이드

04번(Jenkins CI 빌드)과 07번(Tomcat WAR 배포)을 연계하여, **Jenkins 파이프라인에서 WAR 빌드 → Docker 이미지 빌드·푸시 → Kubernetes 배포**까지 한 번에 수행하는 방법을 설명합니다. Jenkins 설치·설정부터 배포 자동화까지 포함합니다.

---

## 목차

1. [개요 및 사전 요구사항](#개요-및-사전-요구사항)
2. [Jenkins 설치 및 기동](#1단계-jenkins-설치-및-기동)
3. [Jenkins 초기 설정 및 플러그인](#2단계-jenkins-초기-설정-및-플러그인)
4. [Credentials 및 연동 설정](#3단계-credentials-및-연동-설정)
5. [Pipeline Job 및 Jenkinsfile 작성](#4단계-pipeline-job-및-jenkinsfile-작성)
6. [Kubernetes 배포 단계 연동](#5단계-kubernetes-배포-단계-연동)
7. [배포 확인 및 트러블슈팅](#6단계-배포-확인-및-트러블슈팅)

---

## 개요 및 사전 요구사항

### 배포 흐름

```
[Git 저장소] → Jenkins (WAR 빌드) → Docker 이미지 빌드 → Private Registry 푸시 → kubectl apply (K8s 배포)
```

### 사전 요구사항

| 항목 | 참고 문서 | 설명 |
|------|-----------|------|
| Kubernetes 클러스터 | 01번 | `kubectl get nodes` 정상, 단일/다중 노드 |
| Private Docker Registry | 02번 | 이미지 push/pull용 (예: `$SERVER_IP:5000`) |
| Jenkins | 04번 | Kubernetes 또는 별도 서버에 Jenkins 배포 |
| Tomcat WAR 배포 구조 | 07번 | Deployment·Service·네임스페이스·imagePullSecrets |

### 필요한 정보 정리

- **Registry 주소**: 예) `192.168.1.100:5000` (Jenkins·kubectl 실행 환경에서 접근 가능한 IP/호스트)
- **Registry 인증**: 02번 문서에서 설정한 ID/비밀번호 (예: admin / admin123)
- **애플리케이션명**: 07번과 동일 (예: `h-cms`)
- **Git 저장소**: WAR 소스 코드가 있는 저장소 URL·브랜치
- **Kubernetes 네임스페이스**: 배포 대상 (예: `dev`)

---

## 1단계: Jenkins 설치 및 기동

04번 문서를 기준으로 Jenkins를 Kubernetes에 배포합니다. 이미 완료했다면 [2단계](#2단계-jenkins-초기-설정-및-플러그인)로 이동하세요.

### 1-1. 스토리지 클래스 확인

```bash
kubectl get storageclass
```

`default` StorageClass가 없으면 04번 문서의 "스토리지 클래스 확인" 절에 따라 local-path-provisioner 또는 수동 PV/PVC를 구성합니다.

### 1-2. 네임스페이스 및 PVC

```bash
kubectl create namespace jenkins
```

```yaml
# jenkins-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pvc
  namespace: jenkins
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

```bash
kubectl apply -f jenkins-pvc.yaml
```

### 1-3. Jenkins Deployment 및 Service

```yaml
# jenkins-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: jenkins
          image: jenkins/jenkins:lts-jdk17
          ports:
            - containerPort: 8080
            - containerPort: 50000
          env:
            - name: JAVA_OPTS
              value: "-Djenkins.install.runSetupWizard=true -Xmx1024m"
          volumeMounts:
            - name: jenkins-home
              mountPath: /var/jenkins_home
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
      volumes:
        - name: jenkins-home
          persistentVolumeClaim:
            claimName: jenkins-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080
      name: http
    - port: 50000
      targetPort: 50000
      name: agent
  selector:
    app: jenkins
```

```bash
kubectl apply -f jenkins-deployment.yaml
kubectl rollout status deployment/jenkins -n jenkins
```

### 1-4. 접속 및 초기 비밀번호

- **접속 URL**: `http://<노드IP>:30080` (노드 IP는 `kubectl get nodes -o wide`로 확인)
- **초기 비밀번호** (Pod 기동 후 1~2분 뒤 확인):

```bash
kubectl exec -n jenkins deployment/jenkins -- cat /var/jenkins_home/secrets/initialAdminPassword
```

출력된 비밀번호로 Jenkins 초기 설정 마법사를 진행합니다.

---

## 2단계: Jenkins 초기 설정 및 플러그인

### 2-1. 초기 설정 마법사

1. **Install suggested plugins** 또는 필요한 플러그인만 선택해 설치
2. **첫 번째 관리자 사용자** 생성 (admin / 비밀번호 등)
3. **Jenkins URL** 확인 (예: `http://jenkins.jenkins.svc.cluster.local:8080`)

### 2-2. Tomcat WAR 배포에 필요한 플러그인

Manage Jenkins → **Plugins** → **Available plugins**에서 다음을 검색해 설치합니다.

| 플러그인 | 용도 |
|---------|------|
| **Pipeline** | Pipeline Job, Jenkinsfile 실행 |
| **Git** | Git 저장소 체크아웃 |
| **Docker Pipeline** | 파이프라인 내 `docker.build()`, `docker.withRegistry()` 등 |
| **Credentials** | 저장소·레지스트리·kubectl 인증 정보 저장 |
| **Kubernetes** | (선택) Kubernetes Cloud로 Agent Pod 실행 |

설치 후 **Restart Jenkins when idle**로 재시작합니다.

### 2-3. Docker Pipeline 사용 시 주의사항

- **Jenkins가 Kubernetes Pod로 동작하는 경우**: Jenkins Pod 안에서는 보통 Docker 데몬이 없습니다. 다음 중 하나가 필요합니다.
  - **Docker-in-Docker (DinD)** sidecar를 Pod에 추가하거나
  - **Kubernetes Pod Template**에서 Docker가 설치된 Agent 이미지를 쓰거나
  - **별도 Docker 호스트**에 Jenkins Agent를 연결해 그 호스트에서 `docker build` 실행

실무에서는 **Docker가 설치된 Agent**에서 빌드하거나, **Kaniko** 등 컨테이너 내부에서 이미지를 빌드하는 방식을 많이 사용합니다. 본 가이드에서는 **Jenkins가 Docker 소켓을 사용할 수 있는 환경**(예: 단일 노드에서 Jenkins가 Docker와 같은 노드에 있거나, Agent에 Docker 설치)을 가정하고, `docker.build()` 예시를 사용합니다.

**Kaniko를 사용하는 경우**는 4단계 Jenkinsfile에서 `docker.build()` 대신 Kaniko 단계로 교체할 수 있습니다 (별도 절에서 간단히 안내).

### 2-4. (선택) Kubernetes Cloud 설정

Manage Jenkins → **Nodes** → **Configure Clouds** → **Add a new cloud** → **Kubernetes**

- **Kubernetes URL**: `https://kubernetes.default`
- **Kubernetes namespace**: `jenkins` 또는 Agent용 네임스페이스
- **Jenkins URL**: `http://jenkins.jenkins.svc.cluster.local:8080`
- **Credentials**: Kubernetes API 접근용 인증(서비스 계정 토큰 등)이 필요하면 등록

Pod Template에서 사용할 이미지에 Maven/Gradle·Docker 클라이언트 등이 포함된 이미지를 지정하면, 해당 Agent에서 WAR 빌드 및 Docker 빌드를 수행할 수 있습니다.

---

## 3단계: Credentials 및 연동 설정

Tomcat WAR 빌드·이미지 푸시·Kubernetes 배포에 필요한 인증 정보를 등록합니다.

### 3-1. Credentials 화면 이동

**Manage Jenkins** → **Credentials** → **System** → **Global credentials** → **Add Credentials**

### 3-2. Private Registry (Docker Registry)

이미지를 push할 레지스트리 인증 정보를 추가합니다.

| 항목 | 값 (예시) |
|------|------------|
| Kind | Username with password |
| Scope | Global |
| Username | 02번 문서의 사용자 (예: `admin`) |
| Password | 02번 문서의 비밀번호 (예: `admin123`) |
| ID | `registry-credentials` (Jenkinsfile에서 사용할 ID) |
| Description | Private Registry 5000 |

**ID**는 Jenkinsfile의 `docker.withRegistry(..., 'registry-credentials')`에서 참조하므로 동일하게 맞춥니다.

### 3-3. Git 저장소 (소스 코드)

WAR 소스가 있는 Git 저장소 접근용입니다.

- **HTTPS**: Kind → **Username with password**, Username/Password에 Git 사용자·토큰
- **SSH**: Kind → **SSH Username with private key**, Key에 개인키 붙여넣기

**ID** 예: `git-credentials` (Pipeline SCM에서 선택)

### 3-4. Kubernetes (kubectl) 배포용

Jenkins에서 `kubectl apply`를 실행하려면 클러스터 접근 권한이 필요합니다. 방법은 두 가지입니다.

#### 방법 A: kubeconfig 파일을 Secret으로 마운트

- 배포가 실행되는 환경(예: Jenkins Agent Pod)에 `kubeconfig`가 마운트되어 있고, `KUBECONFIG` 환경 변수로 그 경로를 가리키게 합니다.
- Jenkins Pod에 kubeconfig를 넣으려면: 노드의 `~/.kube/config`를 Secret으로 만들어 Pod에 마운트하는 방식을 04번 또는 05번 문서 방식으로 구성합니다.

#### 방법 B: Kubernetes 서비스 계정 토큰

1. Jenkins가 배포할 네임스페이스(예: `dev`)에 서비스 계정 생성 및 권한 부여:

```bash
# dev 네임스페이스에 배포 권한이 있는 서비스 계정
kubectl create namespace dev
kubectl create serviceaccount jenkins-deployer -n dev
kubectl create rolebinding jenkins-deployer-binding \
  --clusterrole=edit \
  --serviceaccount=dev:jenkins-deployer \
  -n dev
```

2. 토큰 추출 (Kubernetes 1.24+에서는 Secret이 자동 생성되지 않을 수 있으므로, 직접 토큰을 생성):

```bash
# 1.24+ 인 경우 Long-lived 토큰 생성 예시 (클러스터에 따라 다름)
kubectl create token jenkins-deployer -n dev --duration=87600h
```

3. Jenkins Credentials에 추가:
   - Kind: **Secret text**
   - Secret: 위에서 출력된 토큰 값
   - ID: `k8s-deploy-token`

Jenkins에서 kubectl을 쓰는 경우, **실행 환경(Agent)**에 `kubectl`이 설치되어 있고, 클러스터 API 주소·CA·토큰을 설정해 두어야 합니다. 보통은 **같은 클러스터 안에서 Jenkins Agent가 돌고, Pod에 서비스 계정을 부여**하면 자동으로 인증됩니다. 즉, Agent Pod의 `serviceAccountName`을 `jenkins-deployer`로 두고, 해당 서비스 계정에 `dev` 네임스페이스에 대한 `edit` 권한을 주는 방식입니다.

### 3-5. 요약: Jenkinsfile에서 쓸 Credentials ID

| 용도 | Credentials ID (예시) |
|------|------------------------|
| Docker Registry | `registry-credentials` |
| Git | `git-credentials` 또는 SCM에서 선택한 ID |
| Kubernetes | Agent의 서비스 계정으로 처리하거나, `k8s-deploy-token` 등 |

---

## 4단계: Pipeline Job 및 Jenkinsfile 작성

### 4-1. Pipeline Job 생성

1. **New Item** → 이름 입력 (예: `h-cms-deploy`) → **Pipeline** 선택 → OK
2. **General**
   - 필요 시 **This project is parameterized**로 브랜치·이미지 태그 등 파라미터 추가
3. **Pipeline**
   - **Definition**: **Pipeline script from SCM**
   - **SCM**: Git
   - **Repository URL**: WAR 소스가 있는 Git 저장소 URL
   - **Credentials**: 3단계에서 만든 Git Credentials 선택
   - **Branch**: `*/main` 또는 해당 브랜치
   - **Script Path**: `Jenkinsfile` (저장소 루트의 Jenkinsfile 사용)

### 4-2. 저장소에 넣을 파일

#### Dockerfile (프로젝트 루트 또는 `docker/`)

07번 2단계와 동일. 빌드 산출물 WAR를 `app.war`로 복사합니다.

```dockerfile
FROM tomcat:9-jdk8
COPY app.war /usr/local/tomcat/webapps/ROOT.war
EXPOSE 8080
```

컨텍스트 경로를 `/h-cms`로 쓰려면:

```dockerfile
COPY app.war /usr/local/tomcat/webapps/h-cms.war
```

#### Jenkinsfile (WAR 빌드 → 이미지 빌드·푸시)

아래는 Maven 프로젝트 기준입니다. Gradle이면 `sh 'cp build/libs/*.war app.war'` 등으로 경로만 바꿉니다.

```groovy
pipeline {
  agent any
  environment {
    REGISTRY = '192.168.1.100:5000'   // 실제 Private Registry 주소로 변경
    APP_NAME = 'h-cms'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
```

**수정 포인트**

- `REGISTRY`: 02번 Private Registry 주소 (Jenkins/Agent에서 접근 가능한 IP 또는 호스트명, 예: `192.168.1.100:5000`)
- `APP_NAME`: 07번 Deployment의 이미지 이름과 동일 (예: `h-cms`)
- `target/*.war`: Maven 기본 산출물. Gradle이면 `build/libs/*.war` 등으로 변경
- `registry-credentials`: 3단계에서 등록한 Registry Credentials ID

**Insecure Registry (HTTP 5000)**  
`https://` 없이 사용하는 레지스트리인 경우, Docker 데몬의 `insecure-registries`에 해당 주소를 넣어야 합니다. Jenkins Agent가 사용하는 Docker 호스트에서:

```bash
# /etc/docker/daemon.json
{
  "insecure-registries": ["192.168.1.100:5000"]
}
```

재시작: `sudo systemctl restart docker`

### 4-3. (선택) Kaniko로 이미지 빌드·푸시

Jenkins Pod 안에 Docker가 없는 경우, Kaniko 단계로 대체할 수 있습니다.

```groovy
stage('Docker Build & Push (Kaniko)') {
  steps {
    container('kaniko') {
      sh """
        /kaniko/executor \
          --context \${WORKSPACE} \
          --dockerfile \${WORKSPACE}/Dockerfile \
          --destination ${IMAGE} \
          --destination ${IMAGE_LATEST} \
          --insecure \
          --skip-tls-verify
      """
    }
  }
}
```

이 경우 Kubernetes Pod Template에 `gcr.io/kaniko-project/executor:debug` 같은 Kaniko 이미지를 쓰고, Registry 인증은 Kaniko용 `config.json`을 Secret으로 마운트하는 방식으로 처리합니다. 상세는 Kaniko 문서를 참고하세요.

---

## 5단계: Kubernetes 배포 단계 연동

Jenkins 파이프라인에서 이미지 푸시까지 성공한 뒤, 같은 Job에 **Kubernetes 배포 단계**를 추가합니다.

### 5-1. 배포 매니페스트 위치

- **옵션 A**: 배포 매니페스트를 **Git 저장소**에 포함 (예: `k8s/deployment.yaml`)
- **옵션 B**: Jenkins가 **고정 경로**의 매니페스트 사용 (예: Jenkins Agent 내부 또는 공유 스토리지)

옵션 A를 권장합니다. 저장소에 있으면 버전 관리와 배포 버전 일치가 쉽습니다.

### 5-2. deployment.yaml에서 이미지 주소 치환

07번 5단계의 Deployment에서 `image`를 Jenkins에서 푸시한 이미지로 맞춰야 합니다. 빌드 번호를 태그로 쓰면 롤백이 쉽습니다.

- `image: '<REGISTRY_IP>:5000/h-cms:latest'`  
  또는  
- `image: '<REGISTRY_IP>:5000/h-cms:<BUILD_NUMBER>'`

Jenkinsfile에서 `sed`로 치환한 뒤 `kubectl apply`하는 예시는 아래와 같습니다.

### 5-3. Jenkinsfile에 배포 단계 추가

환경 변수에 `REGISTRY`, `APP_NAME`, `IMAGE`가 이미 있다고 가정합니다.

```groovy
environment {
  REGISTRY = '192.168.1.100:5000'
  APP_NAME = 'h-cms'
  IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
  IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  NAMESPACE = 'dev'
}
```

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
          -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
          k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

또는 **latest**만 쓰는 경우:

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      export REGISTRY_HOST="${REGISTRY.split(':')[0]}"
      sed -e "s|<REGISTRY_IP>|\${REGISTRY_HOST}|g" k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

- `k8s/deployment.yaml`: 07번 5단계의 Deployment·Service 매니페스트. `image`에 `<REGISTRY_IP>`, 필요 시 `:latest` 또는 `:<BUILD_NUMBER>` 패턴을 넣어 두고, 위 `sed`로 치환합니다.
- Jenkins Agent(또는 Jenkins 실행 환경)에 `kubectl`이 설치되어 있고, 클러스터 접근이 가능해야 합니다. Kubernetes Cloud를 쓰는 경우 Agent Pod에 `kubectl` 이미지를 쓰거나, 서비스 계정으로 인증되도록 설정합니다.

### 5-4. 네임스페이스·imagePullSecrets 사전 준비

07번 4단계처럼 배포 전에 한 번 실행해 두세요.

```bash
kubectl create namespace dev
kubectl create secret docker-registry registry-secret \
  --docker-server=192.168.1.100:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n dev
```

Jenkins에서 네임스페이스·시크릿을 만들고 싶다면, 배포 단계 이전에 `kubectl create namespace ...`, `kubectl create secret docker-registry ...` 단계를 Jenkinsfile에 넣을 수 있습니다 (이미 있으면 실패할 수 있으므로 `|| true` 또는 스크립트로 존재 여부 확인 후 생성).

### 5-5. 전체 Jenkinsfile 예시 (WAR 빌드 → 이미지 푸시 → 배포)

```groovy
pipeline {
  agent any
  environment {
    REGISTRY = '192.168.1.100:5000'
    APP_NAME = 'h-cms'
    NAMESPACE = 'dev'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
    stage('Deploy to Kubernetes') {
      steps {
        sh """
          sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
              -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
              k8s/deployment.yaml | kubectl apply -f -
        """
      }
    }
  }
  post {
    always { cleanWs() }
  }
}
```

저장소 구조 예:

```
프로젝트 루트/
  Jenkinsfile
  Dockerfile
  pom.xml
  src/...
  k8s/
    deployment.yaml   # 07번 5단계 내용, image에 <REGISTRY_IP> 등 치환 가능한 값 사용
```

---

## 6단계: 배포 확인 및 트러블슈팅

### 6-1. 파이프라인 실행 후 확인

1. **Console Output**에서 Checkout → Build WAR → Docker Build & Push → Deploy to Kubernetes 순서로 성공 여부 확인
2. **Registry에 이미지 존재 여부**:

```bash
curl -s -u admin:admin123 "http://192.168.1.100:5000/v2/h-cms/tags/list"
```

3. **Pod·Service 상태**:

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

4. **애플리케이션 접근** (07번 6단계 참고):

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
# 브라우저: http://localhost:8080
```

### 6-2. 자주 나오는 오류

| 현상 | 원인 | 조치 |
|------|------|------|
| `docker.build` 실패 | Agent에 Docker 없음 또는 Docker 소켓 미연결 | Docker 사용 가능한 Agent 사용 또는 Kaniko로 전환 |
| `denied: requested access to the resource is denied` | Registry 인증 실패 | Credentials ID·Username/Password 확인, insecure-registries 확인 |
| `ImagePullBackOff` | K8s에서 이미지 pull 실패 | imagePullSecrets·이미지 주소·레지스트리 접근 가능 여부 확인 |
| `kubectl: command not found` | Agent에 kubectl 미설치 | Agent 이미지에 kubectl 포함 또는 설치 단계 추가 |
| `Unable to connect to the server` | kubectl 클러스터 미연결 | KUBECONFIG 또는 서비스 계정 권한 확인 |

### 6-3. 롤백

특정 빌드 번호로 되돌리려면:

```bash
# deployment.yaml의 image를 이전 BUILD_NUMBER로 수정 후
kubectl apply -f k8s/deployment.yaml
# 또는
kubectl set image deployment/h-cms hcms=192.168.1.100:5000/h-cms:<이전빌드번호> -n dev
kubectl rollout status deployment/h-cms -n dev
```

---

## 요약

| 단계 | 내용 |
|------|------|
| 1 | Jenkins 설치 (네임스페이스, PVC, Deployment, Service, NodePort 30080) |
| 2 | 플러그인 (Pipeline, Git, Docker Pipeline, Credentials) 및 보안 설정 |
| 3 | Credentials: Registry, Git, (선택) Kubernetes |
| 4 | Pipeline Job (SCM + Jenkinsfile), Dockerfile·Jenkinsfile 저장소 배치 |
| 5 | Jenkinsfile에 Deploy 단계 추가 (sed + kubectl apply), k8s/deployment.yaml 준비 |
| 6 | Console·Registry·kubectl·브라우저로 배포 결과 확인 |

- **기존 기능 유지**: 01·02·04·07번 문서의 구성(클러스터, Registry, Jenkins, Tomcat 배포)은 그대로 두고, Jenkins만 WAR 빌드 → 이미지 푸시 → Kubernetes 배포까지 연결한 형태입니다.
- **확장**: 05번 Argo CD와 연동하려면, Jenkins는 이미지 푸시만 하고 이미지 태그는 Git(Helm/Kustomize 등)에 반영한 뒤 Argo CD가 배포하도록 구성할 수 있습니다.
