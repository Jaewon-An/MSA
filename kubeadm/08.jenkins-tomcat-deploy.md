# Jenkins로 Tomcat WAR Kubernetes 배포 가이드

04번(Jenkins CI 빌드)과 07번(Tomcat WAR 배포)을 연계하여, **Jenkins 파이프라인에서 WAR 빌드 → Docker 이미지 빌드·푸시 → Kubernetes 배포**까지 한 번에 수행하는 방법을 설명합니다. Jenkins 설치·설정부터 배포 자동화까지 포함합니다.

---

## 목차

1. [개요 및 사전 요구사항](#개요-및-사전-요구사항)
2. [Jenkins 설치 및 기동](#1단계-jenkins-설치-및-기동)
3. [Jenkins 초기 설정 및 플러그인](#2단계-jenkins-초기-설정-및-플러그인)
4. [Credentials 및 연동 설정](#3단계-credentials-및-연동-설정)
5. [Pipeline Job 및 Jenkinsfile 작성](#4단계-pipeline-job-및-jenkinsfile-작성) (Maven 사용 방법 포함)
6. [Kubernetes 배포 단계 연동](#5단계-kubernetes-배포-단계-연동)
7. [배포 확인 및 트러블슈팅](#6단계-배포-확인-및-트러블슈팅)

---

## 개요 및 사전 요구사항

### 배포 흐름

```
[Git 저장소] → Jenkins (WAR 빌드) → Docker 이미지 빌드 → Private Registry 푸시 → kubectl apply (K8s 배포)
```

### 사전 요구사항

| 항목 | 참고 문서 | 설명 |
|------|-----------|------|
| Kubernetes 클러스터 | 01번 | `kubectl get nodes` 정상, 단일/다중 노드 |
| Private Docker Registry | 02번 | 이미지 push/pull용 (예: `$SERVER_IP:5000`) |
| Jenkins | 04번 | Kubernetes 또는 별도 서버에 Jenkins 배포 |
| Tomcat WAR 배포 구조 | 07번 | Deployment·Service·네임스페이스·imagePullSecrets |

### 필요한 정보 정리

- **Registry 주소**: 예) `192.168.1.100:5000` (Jenkins·kubectl 실행 환경에서 접근 가능한 IP/호스트)
- **Registry 인증**: 02번 문서에서 설정한 ID/비밀번호 (예: admin / admin123)
- **애플리케이션명**: 07번과 동일 (예: `h-cms`)
- **Git 저장소**: WAR 소스 코드가 있는 저장소 URL·브랜치
- **Kubernetes 네임스페이스**: 배포 대상 (예: `dev`)

---

## 1단계: Jenkins 설치 및 기동

04번 문서를 기준으로 Jenkins를 Kubernetes에 배포합니다. 이미 완료했다면 [2단계](#2단계-jenkins-초기-설정-및-플러그인)로 이동하세요.

### 1-1. 스토리지 클래스 확인

```bash
kubectl get storageclass
```

`default` StorageClass가 없으면 04번 문서의 "스토리지 클래스 확인" 절에 따라 local-path-provisioner 또는 수동 PV/PVC를 구성합니다.

### 1-2. 네임스페이스 및 PVC

```bash
kubectl create namespace jenkins
```

```yaml
# jenkins-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pvc
  namespace: jenkins
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

```bash
kubectl apply -f jenkins-pvc.yaml
```

### 1-3. Jenkins Deployment 및 Service

```yaml
# jenkins-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: jenkins
          image: jenkins/jenkins:lts-jdk17
          ports:
            - containerPort: 8080
            - containerPort: 50000
          env:
            - name: JAVA_OPTS
              value: "-Djenkins.install.runSetupWizard=true -Xmx1024m"
          volumeMounts:
            - name: jenkins-home
              mountPath: /var/jenkins_home
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
      volumes:
        - name: jenkins-home
          persistentVolumeClaim:
            claimName: jenkins-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080
      name: http
    - port: 50000
      targetPort: 50000
      name: agent
  selector:
    app: jenkins
```

```bash
kubectl apply -f jenkins-deployment.yaml
kubectl rollout status deployment/jenkins -n jenkins
```

### 1-4. 접속 및 초기 비밀번호

- **접속 URL**: `http://<노드IP>:30080` (노드 IP는 `kubectl get nodes -o wide`로 확인)
- **초기 비밀번호** (Pod 기동 후 1~2분 뒤 확인):

```bash
kubectl exec -n jenkins deployment/jenkins -- cat /var/jenkins_home/secrets/initialAdminPassword
```

출력된 비밀번호로 Jenkins 초기 설정 마법사를 진행합니다.

---

## 2단계: Jenkins 초기 설정 및 플러그인

### 2-1. 초기 설정 마법사

1. **Install suggested plugins** 또는 필요한 플러그인만 선택해 설치
2. **첫 번째 관리자 사용자** 생성 (admin / 비밀번호 등)
3. **Jenkins URL** 확인 (예: `http://jenkins.jenkins.svc.cluster.local:8080`)

### 2-2. Tomcat WAR 배포에 필요한 플러그인

Manage Jenkins → **Plugins** → **Available plugins**에서 다음을 검색해 설치합니다.

| 플러그인 | 용도 |
|---------|------|
| **Pipeline** | Pipeline Job, Jenkinsfile 실행 |
| **Git** | Git 저장소 체크아웃 |
| **Docker Pipeline** | 파이프라인 내 `docker.build()`, `docker.withRegistry()` 등 |
| **Credentials** | 저장소·레지스트리·kubectl 인증 정보 저장 |
| **Kubernetes** | (선택) Kubernetes Cloud로 Agent Pod 실행 |
| **Maven Integration** | (선택) Maven 자동 설치·`tools { maven '...' }` 사용 시 권장 |

설치 후 **Restart Jenkins when idle**로 재시작합니다.

### 2-3. Docker Pipeline 사용 시 주의사항

- **Jenkins가 Kubernetes Pod로 동작하는 경우**: Jenkins Pod 안에서는 보통 Docker 데몬이 없습니다. 다음 중 하나가 필요합니다.
  - **Docker-in-Docker (DinD)** sidecar를 Pod에 추가하거나
  - **Kubernetes Pod Template**에서 Docker가 설치된 Agent 이미지를 쓰거나
  - **별도 Docker 호스트**에 Jenkins Agent를 연결해 그 호스트에서 `docker build` 실행

실무에서는 **Docker가 설치된 Agent**에서 빌드하거나, **Kaniko** 등 컨테이너 내부에서 이미지를 빌드하는 방식을 많이 사용합니다. 본 가이드에서는 **Jenkins가 Docker 소켓을 사용할 수 있는 환경**(예: 단일 노드에서 Jenkins가 Docker와 같은 노드에 있거나, Agent에 Docker 설치)을 가정하고, `docker.build()` 예시를 사용합니다.

**Kaniko를 사용하는 경우**는 4단계 Jenkinsfile에서 `docker.build()` 대신 Kaniko 단계로 교체할 수 있습니다 (별도 절에서 간단히 안내).

### 2-4. (선택) Kubernetes Cloud 설정

Manage Jenkins → **Nodes** → **Configure Clouds** → **Add a new cloud** → **Kubernetes**

- **Kubernetes URL**: `https://kubernetes.default`
- **Kubernetes namespace**: `jenkins` 또는 Agent용 네임스페이스
- **Jenkins URL**: `http://jenkins.jenkins.svc.cluster.local:8080`
- **Credentials**: Kubernetes API 접근용 인증(서비스 계정 토큰 등)이 필요하면 등록

Pod Template에서 사용할 이미지에 Maven/Gradle·Docker 클라이언트 등이 포함된 이미지를 지정하면, 해당 Agent에서 WAR 빌드 및 Docker 빌드를 수행할 수 있습니다.

---

## 3단계: Credentials 및 연동 설정

Tomcat WAR 빌드·이미지 푸시·Kubernetes 배포에 필요한 인증 정보를 등록합니다.

### 3-1. Credentials 화면 이동

**Manage Jenkins** → **Credentials** → **System** → **Global credentials** → **Add Credentials**

### 3-2. Private Registry (Docker Registry)

이미지를 push할 레지스트리 인증 정보를 추가합니다.

| 항목 | 값 (예시) |
|------|------------|
| Kind | Username with password |
| Scope | Global |
| Username | 02번 문서의 사용자 (예: `admin`) |
| Password | 02번 문서의 비밀번호 (예: `admin123`) |
| ID | `registry-credentials` (Jenkinsfile에서 사용할 ID) |
| Description | Private Registry 5000 |

**ID**는 Jenkinsfile의 `docker.withRegistry(..., 'registry-credentials')`에서 참조하므로 동일하게 맞춥니다.

### 3-3. Git 저장소 (소스 코드)

WAR 소스가 있는 Git 저장소 접근용입니다.

- **HTTPS**: Kind → **Username with password**, Username/Password에 Git 사용자·토큰
- **SSH**: Kind → **SSH Username with private key**, Key에 개인키 붙여넣기

**ID** 예: `git-credentials` (Pipeline SCM에서 선택)

### 3-4. Kubernetes (kubectl) 배포용

Jenkins에서 `kubectl apply`를 실행하려면 클러스터 접근 권한이 필요합니다. 방법은 두 가지입니다.

#### 방법 A: kubeconfig 파일을 Secret으로 마운트

- 배포가 실행되는 환경(예: Jenkins Agent Pod)에 `kubeconfig`가 마운트되어 있고, `KUBECONFIG` 환경 변수로 그 경로를 가리키게 합니다.
- Jenkins Pod에 kubeconfig를 넣으려면: 노드의 `~/.kube/config`를 Secret으로 만들어 Pod에 마운트하는 방식을 04번 또는 05번 문서 방식으로 구성합니다.

#### 방법 B: Kubernetes 서비스 계정 토큰

1. Jenkins가 배포할 네임스페이스(예: `dev`)에 서비스 계정 생성 및 권한 부여:

```bash
# dev 네임스페이스에 배포 권한이 있는 서비스 계정
kubectl create namespace dev
kubectl create serviceaccount jenkins-deployer -n dev
kubectl create rolebinding jenkins-deployer-binding \
  --clusterrole=edit \
  --serviceaccount=dev:jenkins-deployer \
  -n dev
```

2. 토큰 추출 (Kubernetes 1.24+에서는 Secret이 자동 생성되지 않을 수 있으므로, 직접 토큰을 생성):

```bash
# 1.24+ 인 경우 Long-lived 토큰 생성 예시 (클러스터에 따라 다름)
kubectl create token jenkins-deployer -n dev --duration=87600h
```

3. Jenkins Credentials에 추가:
   - Kind: **Secret text**
   - Secret: 위에서 출력된 토큰 값
   - ID: `k8s-deploy-token`

Jenkins에서 kubectl을 쓰는 경우, **실행 환경(Agent)**에 `kubectl`이 설치되어 있고, 클러스터 API 주소·CA·토큰을 설정해 두어야 합니다. 보통은 **같은 클러스터 안에서 Jenkins Agent가 돌고, Pod에 서비스 계정을 부여**하면 자동으로 인증됩니다. 즉, Agent Pod의 `serviceAccountName`을 `jenkins-deployer`로 두고, 해당 서비스 계정에 `dev` 네임스페이스에 대한 `edit` 권한을 주는 방식입니다.

### 3-5. 요약: Jenkinsfile에서 쓸 Credentials ID

| 용도 | Credentials ID (예시) |
|------|------------------------|
| Docker Registry | `registry-credentials` |
| Git | `git-credentials` 또는 SCM에서 선택한 ID |
| Kubernetes | Agent의 서비스 계정으로 처리하거나, `k8s-deploy-token` 등 |

---

## 4단계: Pipeline Job 및 Jenkinsfile 작성

### 4-1. Pipeline Job 생성

1. **New Item** → 이름 입력 (예: `h-cms-deploy`) → **Pipeline** 선택 → OK
2. **General**
   - 필요 시 **This project is parameterized**로 브랜치·이미지 태그 등 파라미터 추가
3. **Pipeline**
   - **Definition**: **Pipeline script from SCM**
   - **SCM**: Git
   - **Repository URL**: WAR 소스가 있는 Git 저장소 URL
   - **Credentials**: 3단계에서 만든 Git Credentials 선택
   - **Branch**: `*/main` 또는 해당 브랜치
   - **Script Path**: `Jenkinsfile` (저장소 루트의 Jenkinsfile 사용)

### 4-2. 저장소에 넣을 파일

#### Dockerfile (프로젝트 루트 또는 `docker/`)

07번 2단계와 동일. 빌드 산출물 WAR를 `app.war`로 복사합니다.

```dockerfile
FROM tomcat:9-jdk8
COPY app.war /usr/local/tomcat/webapps/ROOT.war
EXPOSE 8080
```

컨텍스트 경로를 `/h-cms`로 쓰려면:

```dockerfile
COPY app.war /usr/local/tomcat/webapps/h-cms.war
```

#### Jenkinsfile (WAR 빌드 → 이미지 빌드·푸시)

아래는 Maven 프로젝트 기준입니다. Gradle이면 `sh 'cp build/libs/*.war app.war'` 등으로 경로만 바꿉니다. **Maven이 Jenkins에 없으면** `mvn: not found` 오류가 나므로, 아래 [4-2-1. mvn: not found 해결](#4-2-1-mvn-not-found-해결-maven-사용-방법)을 먼저 적용한 뒤 사용하세요.

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // Manage Jenkins → Global Tool Configuration에서 등록한 Maven 이름
  }
  environment {
    REGISTRY = '192.168.1.100:5000'   // 실제 Private Registry 주소로 변경
    APP_NAME = 'h-cms'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
```

**수정 포인트**

- `REGISTRY`: 02번 Private Registry 주소 (Jenkins/Agent에서 접근 가능한 IP 또는 호스트명, 예: `192.168.1.100:5000`)
- `APP_NAME`: 07번 Deployment의 이미지 이름과 동일 (예: `h-cms`)
- `target/*.war`: Maven 기본 산출물. Gradle이면 `build/libs/*.war` 등으로 변경
- `registry-credentials`: 3단계에서 등록한 Registry Credentials ID
- `tools { maven 'M3' }`: 4-2-1에서 Jenkins에 등록한 Maven 이름과 일치시킵니다. Maven을 쓰지 않으면 해당 블록을 제거합니다.

### 4-2-1. mvn: not found 해결 (Maven 사용 방법)

Jenkins 기본 이미지(`jenkins/jenkins:lts-jdk17`)에는 **Maven이 포함되어 있지 않습니다**. `mvn clean package` 실행 시 `mvn: not found` 오류가 나면 아래 중 하나를 적용하세요.

#### 방법 1: Jenkins에서 Maven 자동 설치 (권장)

Jenkins가 빌드 시점에 Maven을 설치하고 PATH에 넣어 주는 방식입니다. Docker나 별도 Agent 없이 동작합니다.

1. **Manage Jenkins** → **Tools** (또는 **Global Tool Configuration**) 이동
2. **Maven** 섹션에서 **Add Maven** 클릭
3. 설정 예:
   - **Name**: `M3` (Jenkinsfile의 `tools { maven 'M3' }`와 동일한 이름)
   - **Install automatically** 체크
   - **Install from Apache** 선택 후 원하는 버전 선택 (예: Maven 3.9.6)
4. **Save** 저장

4단계·5단계의 Jenkinsfile에서 **pipeline 상단**에 다음을 넣습니다.

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // 위에서 지정한 Name과 동일
  }
  // ...
}
```

이렇게 하면 해당 Job 실행 시 Maven이 자동 설치되고, `mvn` 명령을 쓸 수 있습니다. (Maven Integration 플러그인이 없으면 **Plugins**에서 "Maven Integration" 설치 후 다시 시도하세요.)

#### 방법 2: Docker로 Maven 빌드 (Docker 사용 가능한 경우)

Jenkins 실행 환경에 Docker가 있고, Docker Pipeline 플러그인이 설치되어 있다면 **Maven이 들어 있는 컨테이너 안에서만** 빌드하도록 할 수 있습니다. Jenkins Controller/Agent에는 Maven을 설치하지 않아도 됩니다.

```groovy
stage('Build WAR') {
  steps {
    script {
      docker.image('maven:3.8-eclipse-temurin-8').inside("-v ${env.HOME}/.m2:/root/.m2") {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
  }
}
```

- `maven:3.8-eclipse-temurin-8`: JDK 8 기반 Maven 이미지. JDK 11이 필요하면 `maven:3.8-eclipse-temurin-11` 등으로 변경
- `-v ${env.HOME}/.m2:/root/.m2`: 로컬 Maven 캐시를 컨테이너에 마운트해 의존성 재다운로드를 줄임

**주의**: Jenkins가 Kubernetes Pod로만 동작하고 Docker 소켓이 없다면 `docker.image().inside()`는 사용할 수 없습니다. 이 경우 **방법 1**을 사용하세요.

### 4-2-2. HTTP 저장소 차단 (maven-default-http-blocker)

**증상**: 빌드 시 `Blocked mirror for repositories: ... maven-default-http-blocker (http://0.0.0.0/)` 또는 `Could not transfer artifact ... from/to maven-default-http-blocker` 오류가 발생합니다.

**원인**: Maven **3.8.1**부터 보안상 **HTTP** 원격 저장소 접근이 기본으로 차단됩니다. 사내 Nexus(`http://10.10.1.2:8081/...`)나 `http://maven3.yooncoms.co.kr/...` 같은 HTTP 저장소를 쓰면 이 정책에 걸립니다.

#### 해결 1: Maven 3.8 미만 버전 사용 (가장 간단)

Jenkins **Global Tool Configuration** → Maven에서 **3.6.3** 등 **3.8 미만** 버전을 선택해 설치합니다. 3.6.x는 HTTP 저장소를 막지 않습니다.

- **Add Maven** → Name: `M3` → **Install automatically** → **Install from Apache** → **3.6.3** 선택 → Save  
- Jenkinsfile의 `tools { maven 'M3' }`는 그대로 두면 됩니다.

#### 해결 2: settings.xml으로 HTTP 차단 해제 (Maven 3.8+ 유지 시)

Maven 3.8+를 계속 쓰려면, 기본 HTTP 차단 미러를 **덮어쓰기**하는 `settings.xml`을 사용합니다.

1. **Jenkins에서 사용할 Maven settings.xml** (예: Job용 Config File 또는 저장소에 포함)

`settings.xml` 내용 예시:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd">
  <mirrors>
    <!-- Maven 3.8.1+ 기본 HTTP 차단을 해제 (동일 id로 blocked=false 설정) -->
    <mirror>
      <id>maven-default-http-blocker</id>
      <mirrorOf>external:http:*</mirrorOf>
      <name>Pseudo repository to mirror external repositories initially using HTTP.</name>
      <url>http://0.0.0.0/</url>
      <blocked>false</blocked>
    </mirror>
  </mirrors>
  <!-- 필요 시 사내 Nexus 등 repository/pluginRepository도 여기에 정의 -->
</settings>
```

2. **Jenkins에 적용하는 방법**

- **방법 A – 저장소에 두고 `-s`로 지정**  
  프로젝트 루트 또는 `ci/settings.xml`에 위 내용을 넣고, Jenkinsfile의 Maven 단계에서:

  ```groovy
  sh 'mvn clean package -DskipTests -s ci/settings.xml'
  ```

- **방법 B – Config File Management 플러그인**  
  Manage Jenkins → **Config File Management** → **Add a new Config** → **Maven settings.xml** 선택 후 위 내용 붙여넣기.  
  Pipeline Job 설정에서 **Pipeline** 아래 **Use custom Maven settings** 체크 후 해당 설정 파일 선택.  
  그러면 Jenkins가 자동으로 `-s ...` 로 그 설정을 사용합니다.

- **방법 C – Global Tool Configuration에서 기본 settings 지정**  
  Global Tool Configuration → Maven → 해당 Maven 항목의 **Global settings file**에 위 내용의 설정 파일을 지정할 수 있으면, 전역으로 적용됩니다 (Jenkins 버전/플러그인에 따라 지원 여부 다름).

**주의**: HTTP 저장소를 다시 허용하는 것이므로, 신뢰할 수 있는 사내/특정 저장소에만 사용하는 것을 권장합니다.

### 4-2-3. Java heap space (Maven WAR 빌드 시 메모리 부족)

**증상**: `maven-war-plugin` 실행 중 `Error assembling WAR: ... Java heap space` 또는 `java.lang.OutOfMemoryError: Java heap space` 오류가 발생합니다.

**원인**: Maven이 사용하는 JVM 힙 메모리가 부족합니다. 대형 프로젝트나 멀티 모듈 빌드에서 WAR 조립 시 메모리를 많이 쓰면 발생합니다.

#### 해결: Maven 실행 시 힙 크기 늘리기

Maven이 사용하는 JVM 옵션을 **MAVEN_OPTS** 환경 변수로 지정합니다. Jenkins에서는 파이프라인 `environment` 또는 Build WAR 단계 직전에 설정하면 됩니다.

**방법 A – Jenkinsfile의 environment에 추가 (권장)**

```groovy
pipeline {
  agent any
  tools { maven 'M3' }
  environment {
    MAVEN_OPTS = '-Xmx1024m -Xms256m'   // 최대 1GB 힙. 부족하면 2048m 등으로 증가
    REGISTRY = '192.168.1.100:5000'
    APP_NAME = 'h-cms'
    // ...
  }
  stages {
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    // ...
  }
}
```

- `-Xmx1024m`: 최대 힙 1GB. 여전히 부족하면 `-Xmx2048m`, `-Xmx3072m` 등으로 올립니다.
- `-Xms256m`: 초기 힙 (선택). 지정하면 초기 할당 크기가 고정됩니다.

**방법 B – Build WAR 단계에서만 지정**

```groovy
stage('Build WAR') {
  steps {
    sh 'export MAVEN_OPTS="-Xmx2048m -Xms512m" && mvn clean package -DskipTests'
    sh 'cp target/*.war app.war'
  }
}
```

**방법 C – Jenkins Global Tool Configuration**

Manage Jenkins → **Tools** → Maven → 해당 Maven 항목 → **Properties** (또는 **Advanced**)에 다음 추가:

- **Name**: `MAVEN_OPTS`  
- **Value**: `-Xmx2048m -Xms512m`

(항목 이름이 "Environment variables" 등으로 되어 있으면 `MAVEN_OPTS=-Xmx2048m` 형태로 넣습니다.)

**참고**: Jenkins Pod/Agent의 메모리 한도보다 Maven 힙을 너무 크게 주면 OOMKilled 될 수 있으므로, Pod의 `resources.limits.memory`(예: 2Gi)보다 작게 `-Xmx`를 설정하는 것이 좋습니다.

**Insecure Registry (HTTP 5000)**  
`https://` 없이 사용하는 레지스트리인 경우, Docker 데몬의 `insecure-registries`에 해당 주소를 넣어야 합니다. Jenkins Agent가 사용하는 Docker 호스트에서:

```bash
# /etc/docker/daemon.json
{
  "insecure-registries": ["192.168.1.100:5000"]
}
```

재시작: `sudo systemctl restart docker`

### 4-3. (선택) Kaniko로 이미지 빌드·푸시

Jenkins Pod 안에 Docker가 없는 경우, Kaniko 단계로 대체할 수 있습니다.

```groovy
stage('Docker Build & Push (Kaniko)') {
  steps {
    container('kaniko') {
      sh """
        /kaniko/executor \
          --context \${WORKSPACE} \
          --dockerfile \${WORKSPACE}/Dockerfile \
          --destination ${IMAGE} \
          --destination ${IMAGE_LATEST} \
          --insecure \
          --skip-tls-verify
      """
    }
  }
}
```

이 경우 Kubernetes Pod Template에 `gcr.io/kaniko-project/executor:debug` 같은 Kaniko 이미지를 쓰고, Registry 인증은 Kaniko용 `config.json`을 Secret으로 마운트하는 방식으로 처리합니다. 상세는 Kaniko 문서를 참고하세요.

---

## 5단계: Kubernetes 배포 단계 연동

Jenkins 파이프라인에서 이미지 푸시까지 성공한 뒤, 같은 Job에 **Kubernetes 배포 단계**를 추가합니다.

### 5-1. 배포 매니페스트 위치

- **옵션 A**: 배포 매니페스트를 **Git 저장소**에 포함 (예: `k8s/deployment.yaml`)
- **옵션 B**: Jenkins가 **고정 경로**의 매니페스트 사용 (예: Jenkins Agent 내부 또는 공유 스토리지)

옵션 A를 권장합니다. 저장소에 있으면 버전 관리와 배포 버전 일치가 쉽습니다.

### 5-2. deployment.yaml에서 이미지 주소 치환

07번 5단계의 Deployment에서 `image`를 Jenkins에서 푸시한 이미지로 맞춰야 합니다. 빌드 번호를 태그로 쓰면 롤백이 쉽습니다.

- `image: '<REGISTRY_IP>:5000/h-cms:latest'`  
  또는  
- `image: '<REGISTRY_IP>:5000/h-cms:<BUILD_NUMBER>'`

Jenkinsfile에서 `sed`로 치환한 뒤 `kubectl apply`하는 예시는 아래와 같습니다.

### 5-3. Jenkinsfile에 배포 단계 추가

환경 변수에 `REGISTRY`, `APP_NAME`, `IMAGE`가 이미 있다고 가정합니다.

```groovy
environment {
  REGISTRY = '192.168.1.100:5000'
  APP_NAME = 'h-cms'
  IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
  IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  NAMESPACE = 'dev'
}
```

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
          -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
          k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

또는 **latest**만 쓰는 경우:

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      export REGISTRY_HOST="${REGISTRY.split(':')[0]}"
      sed -e "s|<REGISTRY_IP>|\${REGISTRY_HOST}|g" k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

- `k8s/deployment.yaml`: 07번 5단계의 Deployment·Service 매니페스트. `image`에 `<REGISTRY_IP>`, 필요 시 `:latest` 또는 `:<BUILD_NUMBER>` 패턴을 넣어 두고, 위 `sed`로 치환합니다.
- Jenkins Agent(또는 Jenkins 실행 환경)에 `kubectl`이 설치되어 있고, 클러스터 접근이 가능해야 합니다. Kubernetes Cloud를 쓰는 경우 Agent Pod에 `kubectl` 이미지를 쓰거나, 서비스 계정으로 인증되도록 설정합니다.

### 5-4. 네임스페이스·imagePullSecrets 사전 준비

07번 4단계처럼 배포 전에 한 번 실행해 두세요.

```bash
kubectl create namespace dev
kubectl create secret docker-registry registry-secret \
  --docker-server=192.168.1.100:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n dev
```

Jenkins에서 네임스페이스·시크릿을 만들고 싶다면, 배포 단계 이전에 `kubectl create namespace ...`, `kubectl create secret docker-registry ...` 단계를 Jenkinsfile에 넣을 수 있습니다 (이미 있으면 실패할 수 있으므로 `|| true` 또는 스크립트로 존재 여부 확인 후 생성).

### 5-5. 전체 Jenkinsfile 예시 (WAR 빌드 → 이미지 푸시 → 배포)

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // Global Tool Configuration에서 등록한 Maven 이름
  }
  environment {
    REGISTRY = '192.168.1.100:5000'
    APP_NAME = 'h-cms'
    NAMESPACE = 'dev'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
    stage('Deploy to Kubernetes') {
      steps {
        sh """
          sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
              -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
              k8s/deployment.yaml | kubectl apply -f -
        """
      }
    }
  }
  post {
    always { cleanWs() }
  }
}
```

저장소 구조 예:

```
프로젝트 루트/
  Jenkinsfile
  Dockerfile
  pom.xml
  src/...
  k8s/
    deployment.yaml   # 07번 5단계 내용, image에 <REGISTRY_IP> 등 치환 가능한 값 사용
```

---

## 6단계: 배포 확인 및 트러블슈팅

### 6-1. 파이프라인 실행 후 확인

1. **Console Output**에서 Checkout → Build WAR → Docker Build & Push → Deploy to Kubernetes 순서로 성공 여부 확인
2. **Registry에 이미지 존재 여부**:

```bash
curl -s -u admin:admin123 "http://192.168.1.100:5000/v2/h-cms/tags/list"
```

3. **Pod·Service 상태**:

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

4. **애플리케이션 접근** (07번 6단계 참고):

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
# 브라우저: http://localhost:8080
```

### 6-2. 자주 나오는 오류

| 현상 | 원인 | 조치 |
|------|------|------|
| `mvn: not found` | Jenkins 이미지에 Maven 미포함 | [4-2-1](#4-2-1-mvn-not-found-해결-maven-사용-방법): Global Tool Configuration에서 Maven 자동 설치 후 `tools { maven 'M3' }` 사용, 또는 Docker로 Maven 컨테이너 사용 |
| `maven-default-http-blocker`, HTTP 저장소 차단 | Maven 3.8.1+ 기본 정책으로 HTTP 저장소 차단 | [4-2-2](#4-2-2-http-저장소-차단-maven-default-http-blocker): Maven 3.6.3 사용 또는 settings.xml에 `maven-default-http-blocker`를 `blocked=false`로 덮어쓰기 |
| `Java heap space`, `Error assembling WAR` | Maven JVM 힙 부족 | [4-2-3](#4-2-3-java-heap-space-maven-war-빌드-시-메모리-부족): Jenkinsfile `environment`에 `MAVEN_OPTS=-Xmx1024m` 또는 `-Xmx2048m` 설정 |
| `docker.build` 실패 | Agent에 Docker 없음 또는 Docker 소켓 미연결 | Docker 사용 가능한 Agent 사용 또는 Kaniko로 전환 |
| `denied: requested access to the resource is denied` | Registry 인증 실패 | Credentials ID·Username/Password 확인, insecure-registries 확인 |
| `ImagePullBackOff` | K8s에서 이미지 pull 실패 | imagePullSecrets·이미지 주소·레지스트리 접근 가능 여부 확인 |
| `kubectl: command not found` | Agent에 kubectl 미설치 | Agent 이미지에 kubectl 포함 또는 설치 단계 추가 |
| `Unable to connect to the server` | kubectl 클러스터 미연결 | KUBECONFIG 또는 서비스 계정 권한 확인 |

### 6-3. 롤백

특정 빌드 번호로 되돌리려면:

```bash
# deployment.yaml의 image를 이전 BUILD_NUMBER로 수정 후
kubectl apply -f k8s/deployment.yaml
# 또는
kubectl set image deployment/h-cms hcms=192.168.1.100:5000/h-cms:<이전빌드번호> -n dev
kubectl rollout status deployment/h-cms -n dev
```

---

## 요약

| 단계 | 내용 |
|------|------|
| 1 | Jenkins 설치 (네임스페이스, PVC, Deployment, Service, NodePort 30080) |
| 2 | 플러그인 (Pipeline, Git, Docker Pipeline, Credentials) 및 보안 설정 |
| 3 | Credentials: Registry, Git, (선택) Kubernetes |
| 4 | Pipeline Job (SCM + Jenkinsfile), Dockerfile·Jenkinsfile 저장소 배치 |
| 5 | Jenkinsfile에 Deploy 단계 추가 (sed + kubectl apply), k8s/deployment.yaml 준비 |
| 6 | Console·Registry·kubectl·브라우저로 배포 결과 확인 |

- **기존 기능 유지**: 01·02·04·07번 문서의 구성(클러스터, Registry, Jenkins, Tomcat 배포)은 그대로 두고, Jenkins만 WAR 빌드 → 이미지 푸시 → Kubernetes 배포까지 연결한 형태입니다.
- **확장**: 05번 Argo CD와 연동하려면, Jenkins는 이미지 푸시만 하고 이미지 태그는 Git(Helm/Kustomize 등)에 반영한 뒤 Argo CD가 배포하도록 구성할 수 있습니다.
