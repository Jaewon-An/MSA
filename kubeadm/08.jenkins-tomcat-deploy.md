# Jenkins로 Tomcat WAR Kubernetes 배포 가이드

04번(Jenkins CI 빌드, **Linux 직접 설치**)과 07번(Tomcat WAR 배포)을 연계하여, **Jenkins 파이프라인에서 WAR 빌드 → Docker 이미지 빌드·푸시 → Kubernetes 배포**까지 한 번에 수행하는 방법을 설명합니다.
Jenkins는 04번 문서에 따라 Linux 서버에 직접 설치된 환경을 기준으로 합니다.

---

## 목차

1. [개요 및 사전 요구사항](#개요-및-사전-요구사항)
2. [1단계: Jenkins 설치 및 기동](#1단계-jenkins-설치-및-기동)
3. [2단계: Jenkins 초기 설정 및 플러그인](#2단계-jenkins-초기-설정-및-플러그인)
4. [3단계: Credentials 및 연동 설정](#3단계-credentials-및-연동-설정)
5. [4단계: Pipeline Job 및 Jenkinsfile 작성](#4단계-pipeline-job-및-jenkinsfile-작성) (Maven 사용 방법 포함)
6. [5단계: Kubernetes 배포 단계 연동](#5단계-kubernetes-배포-단계-연동)
7. [6단계: 배포 확인 및 트러블슈팅](#6단계-배포-확인-및-트러블슈팅)

---

## 개요 및 사전 요구사항

### 배포 흐름

```
[Git 저장소] → Jenkins (WAR 빌드) → Docker 이미지 빌드 → Private Registry 푸시 → kubectl apply (K8s 배포)
```

### 사전 요구사항

| 항목                    | 참고 문서 | 설명                                                |
| ----------------------- | --------- | --------------------------------------------------- |
| Kubernetes 클러스터     | 01번      | `kubectl get nodes` 정상, 단일/다중 노드            |
| Private Docker Registry | 02번      | 이미지 push/pull용 (예: `$SERVER_IP:5000`)          |
| Jenkins                 | 04번      | Linux 서버에 Jenkins 직접 설치 (systemd, 포트 8080) |
| Tomcat WAR 배포 구조    | 07번      | Deployment·Service·네임스페이스·imagePullSecrets    |

### 필요한 정보 정리

- **Registry 주소**: 예) `172.16.0.194:5000` (Jenkins·kubectl 실행 환경에서 접근 가능한 IP/호스트)
- **Registry 인증**: 02번 문서에서 설정한 ID/비밀번호 (예: admin / admin123)
- **애플리케이션명**: 07번과 동일 (예: `h-cms`)
- **Git 저장소**: WAR 소스 코드가 있는 저장소 URL·브랜치
- **Kubernetes 네임스페이스**: 배포 대상 (예: `dev`)

---

## 1단계: Jenkins 설치 및 기동

**04번 문서** [Jenkins 기반 CI 빌드 가이드 (Linux 직접 설치)](04.jenkins-build.md)에 따라 Linux 서버에 Jenkins를 직접 설치·기동합니다.

- 미설치 시: 04번 문서 1~5단계 진행 후, 초기 비밀번호는 `sudo cat /data/jenkins/secrets/initialAdminPassword`로 확인
- 설치 완료 시: [2단계](#2단계-jenkins-초기-설정-및-플러그인)로 이동

---

## 2단계: Jenkins 초기 설정 및 플러그인

04번 문서 6단계를 참고해 초기 설정 마법사(관리자 생성, Jenkins URL)를 완료한 뒤, 아래 플러그인을 설치합니다.

| 플러그인          | 용도                                           |
| ----------------- | ---------------------------------------------- |
| Pipeline          | Pipeline Job, Jenkinsfile                      |
| Git               | Git 저장소 체크아웃                            |
| Docker Pipeline   | `docker.build()`, `docker.withRegistry()`      |
| Credentials       | 저장소·레지스트리·kubectl 인증                 |
| Maven Integration | (선택) Maven 자동 설치, `tools { maven 'M3' }` |

- **Docker 사용**: 04번 7-2단계처럼 같은 서버에 Docker 설치 후 `usermod -aG docker jenkins`, Jenkins 재시작. Docker를 쓸 수 없으면 4-3절 Kaniko로 대체 가능.
- **Kubernetes Cloud**: Agent Pod 사용 시에만 04번 6-3절 참고. 기본은 `agent any`로 동일 서버 빌드.

---

## 3단계: Credentials 및 연동 설정

Tomcat WAR 빌드·이미지 푸시·Kubernetes 배포에 필요한 인증 정보를 등록합니다.

### 3-1. Credentials 화면 이동

**Manage Jenkins** → **Credentials** → **System** → **Global credentials** → **Add Credentials**

### 3-2. Private Registry (Docker Registry)

이미지를 push할 레지스트리 인증 정보를 추가합니다.

| 항목        | 값 (예시)                                          |
| ----------- | -------------------------------------------------- |
| Kind        | Username with password                             |
| Scope       | Global                                             |
| Username    | 02번 문서의 사용자 (예: `admin`)                   |
| Password    | 02번 문서의 비밀번호 (예: `admin123`)              |
| ID          | `registry-credentials` (Jenkinsfile에서 사용할 ID) |
| Description | Private Registry 5000                              |

**ID**는 Jenkinsfile의 `docker.withRegistry(..., 'registry-credentials')`에서 참조하므로 동일하게 맞춥니다.

### 3-3. Git 저장소 (소스 코드)

WAR 소스가 있는 Git 저장소 접근용입니다.

- **HTTPS**: Kind → **Username with password**, Username/Password에 Git 사용자·토큰
- **SSH**: Kind → **SSH Username with private key**, Key에 개인키 붙여넣기

**ID** 예: `git-credentials` (Pipeline SCM에서 선택)

### 3-4. Kubernetes (kubectl) 배포용

Jenkins에서 `kubectl apply`를 실행하려면 클러스터 접근 권한이 필요합니다. **04번에서 Linux에 직접 설치한 Jenkins**인 경우:

- **방법 A: Jenkins 서버에 kubeconfig 복사 (권장)** 클러스터 노드의 `~/.kube/config`를 Jenkins 사용자 홈(예: `/data/jenkins/.kube/config`)에 복사하고, 해당 파일에 대한 읽기 권한을 jenkins 사용자에게
  부여합니다. 자세한 절차는 **04번 문서 7단계 (kubectl)** 를 참고하세요.

#### 방법 B: Kubernetes 서비스 계정 토큰

1. Jenkins가 배포할 네임스페이스(예: `dev`)에 서비스 계정 생성 및 권한 부여:

```bash
# dev 네임스페이스에 배포 권한이 있는 서비스 계정
kubectl create namespace dev
kubectl create serviceaccount jenkins-deployer -n dev
kubectl create rolebinding jenkins-deployer-binding \
  --clusterrole=edit \
  --serviceaccount=dev:jenkins-deployer \
  -n dev
```

2. 토큰 추출 (Kubernetes 1.24+에서는 Secret이 자동 생성되지 않을 수 있으므로, 직접 토큰을 생성):

```bash
# 1.24+ 인 경우 Long-lived 토큰 생성 예시 (클러스터에 따라 다름)
kubectl create token jenkins-deployer -n dev --duration=87600h
```

3. Jenkins Credentials에 추가:
    - Kind: **Secret text**
    - Secret: 위에서 출력된 토큰 값
    - ID: `k8s-deploy-token`

Jenkins에서 kubectl을 쓰는 경우, **실행 환경(Agent)**에 `kubectl`이 설치되어 있고, 클러스터 API 주소·CA·토큰을 설정해 두어야 합니다. 보통은 **같은 클러스터 안에서 Jenkins Agent가 돌고, Pod에 서비스
계정을 부여**하면 자동으로 인증됩니다. 즉, Agent Pod의 `serviceAccountName`을 `jenkins-deployer`로 두고, 해당 서비스 계정에 `dev` 네임스페이스에 대한 `edit` 권한을 주는 방식입니다.

### 3-5. 요약: Jenkinsfile에서 쓸 Credentials ID

| 용도            | Credentials ID (예시)                                     |
| --------------- | --------------------------------------------------------- |
| Docker Registry | `registry-credentials`                                    |
| Git             | `git-credentials` 또는 SCM에서 선택한 ID                  |
| Kubernetes      | Agent의 서비스 계정으로 처리하거나, `k8s-deploy-token` 등 |

---

## 4단계: Pipeline Job 및 Jenkinsfile 작성

### 4-1. Pipeline Job 생성

1. **New Item** → 이름 입력 (예: `h-cms-deploy`) → **Pipeline** 선택 → OK
2. **General**
    - 필요 시 **This project is parameterized**로 브랜치·이미지 태그 등 파라미터 추가
3. **Pipeline**
    - **Definition**: **Pipeline script from SCM**
    - **SCM**: Git
    - **Repository URL**: WAR 소스가 있는 Git 저장소 URL
    - **Credentials**: 3단계에서 만든 Git Credentials 선택
    - **Branch**: `*/main` 또는 해당 브랜치
    - **Script Path**: `Jenkinsfile` (저장소 루트의 Jenkinsfile 사용)

### 4-2. 저장소에 넣을 파일

#### Dockerfile (프로젝트 루트 또는 `docker/`)

07번 2단계와 동일. 빌드 산출물 WAR를 `app.war`로 복사합니다.

```dockerfile
FROM tomcat:9-jdk8
COPY app.war /usr/local/tomcat/webapps/ROOT.war
EXPOSE 8080
```

컨텍스트 경로를 `/h-cms`로 쓰려면:

```dockerfile
COPY app.war /usr/local/tomcat/webapps/h-cms.war
```

#### Jenkinsfile (WAR 빌드 → 이미지 빌드·푸시)

아래는 Maven 프로젝트 기준입니다. Gradle이면 `sh 'cp build/libs/*.war app.war'` 등으로 경로만 바꿉니다. **Maven이 Jenkins에 없으면** `mvn: not found` 오류가 나므로, 아래
[4-2-1. mvn: not found 해결](#4-2-1-mvn-not-found-해결-maven-사용-방법)을 먼저 적용한 뒤 사용하세요.

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // Manage Jenkins → Global Tool Configuration에서 등록한 Maven 이름
  }
  environment {
    REGISTRY = '172.16.0.194:5000'   // 실제 Private Registry 주소로 변경
    APP_NAME = 'h-cms'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        // 단일 모듈: target/*.war / 멀티 모듈: WAR가 나오는 서브모듈 경로 사용 (아래 4-2-4 참고)
        sh 'cp humanframe.web/target/*.war app.war'
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
  }
  post {
    always {
      deleteDir()   // 워크스페이스 정리 (cleanWs는 Workspace Cleanup 플러그인 필요)
    }
  }
}
```

**실행 환경**: 위 파이프라인은 **Kubernetes 노드가 아닌 일반 에이전트**(`agent any`)에서 동작합니다. Jenkins Controller(빌트인 노드) 또는 Docker가 설치된 일반 에이전트에서 실행하면 되며, Kubernetes
Cloud/Agent는 필수가 아닙니다. 해당 노드에 Docker CLI·데몬이 있어야 `docker.build()`가 동작합니다.

**수정 포인트**

- `REGISTRY`: 02번 Private Registry 주소 (Jenkins/Agent에서 접근 가능한 IP 또는 호스트명, 예: `172.16.0.194:5000`)
- `APP_NAME`: 07번 Deployment의 이미지 이름과 동일 (예: `h-cms`)
- WAR 복사 경로: 단일 모듈이면 `target/*.war`, 멀티 모듈이면 WAR를 빌드하는 서브모듈 경로 (예: `humanframe.web/target/*.war`). 자세한 내용은 [4-2-4](#4-2-4-멀티-모듈에서-war-파일-경로) 참고.
- `registry-credentials`: 3단계에서 등록한 Registry Credentials ID
- `tools { maven 'M3' }`: 4-2-1에서 Jenkins에 등록한 Maven 이름과 일치시킵니다. Maven을 쓰지 않으면 해당 블록을 제거합니다.

### 4-2-1. mvn: not found 해결 (Maven 사용 방법)

04번에서 **Linux에 직접 설치한 Jenkins**에는 기본적으로 Maven이 포함되어 있지 않습니다. `mvn clean package` 실행 시 `mvn: not found` 오류가 나면 아래 중 하나를 적용하세요.

#### 방법 1: Jenkins에서 Maven 자동 설치 (권장)

Jenkins가 빌드 시점에 Maven을 설치하고 PATH에 넣어 주는 방식입니다. Docker나 별도 Agent 없이 동작합니다.

1. **Manage Jenkins** → **Tools** (또는 **Global Tool Configuration**) 이동
2. **Maven** 섹션에서 **Add Maven** 클릭
3. 설정 예:
    - **Name**: `M3` (Jenkinsfile의 `tools { maven 'M3' }`와 동일한 이름)
    - **Install automatically** 체크
    - **Install from Apache** 선택 후 원하는 버전 선택 (예: Maven 3.9.6)
4. **Save** 저장

4단계·5단계의 Jenkinsfile에서 **pipeline 상단**에 다음을 넣습니다.

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // 위에서 지정한 Name과 동일
  }
  // ...
}
```

이렇게 하면 해당 Job 실행 시 Maven이 자동 설치되고, `mvn` 명령을 쓸 수 있습니다. (Maven Integration 플러그인이 없으면 **Plugins**에서 "Maven Integration" 설치 후 다시 시도하세요.)

#### 방법 2: Docker로 Maven 빌드 (Docker 사용 가능한 경우)

Jenkins 실행 환경에 Docker가 있고, Docker Pipeline 플러그인이 설치되어 있다면 **Maven이 들어 있는 컨테이너 안에서만** 빌드하도록 할 수 있습니다. Jenkins Controller/Agent에는 Maven을 설치하지 않아도
됩니다.

```groovy
stage('Build WAR') {
  steps {
    script {
      docker.image('maven:3.8-eclipse-temurin-8').inside("-v ${env.HOME}/.m2:/root/.m2") {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
  }
}
```

- `maven:3.8-eclipse-temurin-8`: JDK 8 기반 Maven 이미지. JDK 11이 필요하면 `maven:3.8-eclipse-temurin-11` 등으로 변경
- `-v ${env.HOME}/.m2:/root/.m2`: 로컬 Maven 캐시를 컨테이너에 마운트해 의존성 재다운로드를 줄임

**주의**: Jenkins 실행 환경에 Docker가 없거나 Docker 소켓을 쓸 수 없다면 `docker.image().inside()`는 사용할 수 없습니다. 이 경우 **방법 1**(Maven 자동 설치)을 사용하세요.

### 4-2-2. HTTP 저장소 차단 (maven-default-http-blocker)

**증상**: 빌드 시 `Blocked mirror for repositories: ... maven-default-http-blocker (http://0.0.0.0/)` 또는 `Could not transfer artifact ... from/to maven-default-http-blocker` 오류가 발생합니다.

**원인**: Maven **3.8.1**부터 보안상 **HTTP** 원격 저장소 접근이 기본으로 차단됩니다. 사내 Nexus(`http://10.10.1.2:8081/...`)나 `http://maven3.yooncoms.co.kr/...` 같은 HTTP 저장소를 쓰면 이 정책에
걸립니다.

#### 해결 1: Maven 3.8 미만 버전 사용 (가장 간단)

Jenkins **Global Tool Configuration** → Maven에서 **3.6.3** 등 **3.8 미만** 버전을 선택해 설치합니다. 3.6.x는 HTTP 저장소를 막지 않습니다.

- **Add Maven** → Name: `M3` → **Install automatically** → **Install from Apache** → **3.6.3** 선택 → Save
- Jenkinsfile의 `tools { maven 'M3' }`는 그대로 두면 됩니다.

#### 해결 2: settings.xml으로 HTTP 차단 해제 (Maven 3.8+ 유지 시)

Maven 3.8+를 계속 쓰려면, 기본 HTTP 차단 미러를 **덮어쓰기**하는 `settings.xml`을 사용합니다.

1. **Jenkins에서 사용할 Maven settings.xml** (예: Job용 Config File 또는 저장소에 포함)

`settings.xml` 내용 예시:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd">
  <mirrors>
    <!-- Maven 3.8.1+ 기본 HTTP 차단을 해제 (동일 id로 blocked=false 설정) -->
    <mirror>
      <id>maven-default-http-blocker</id>
      <mirrorOf>external:http:*</mirrorOf>
      <name>Pseudo repository to mirror external repositories initially using HTTP.</name>
      <url>http://0.0.0.0/</url>
      <blocked>false</blocked>
    </mirror>
  </mirrors>
  <!-- 필요 시 사내 Nexus 등 repository/pluginRepository도 여기에 정의 -->
</settings>
```

2. **Jenkins에 적용하는 방법**

- **방법 A – 저장소에 두고 `-s`로 지정** 프로젝트 루트 또는 `ci/settings.xml`에 위 내용을 넣고, Jenkinsfile의 Maven 단계에서:

    ```groovy
    sh 'mvn clean package -DskipTests -s ci/settings.xml'
    ```

- **방법 B – Config File Management 플러그인** Manage Jenkins → **Config File Management** → **Add a new Config** → **Maven settings.xml** 선택 후 위 내용 붙여넣기. Pipeline Job 설정에서 **Pipeline**
  아래 **Use custom Maven settings** 체크 후 해당 설정 파일 선택. 그러면 Jenkins가 자동으로 `-s ...` 로 그 설정을 사용합니다.

- **방법 C – Global Tool Configuration에서 기본 settings 지정** Global Tool Configuration → Maven → 해당 Maven 항목의 **Global settings file**에 위 내용의 설정 파일을 지정할 수 있으면, 전역으로
  적용됩니다 (Jenkins 버전/플러그인에 따라 지원 여부 다름).

**주의**: HTTP 저장소를 다시 허용하는 것이므로, 신뢰할 수 있는 사내/특정 저장소에만 사용하는 것을 권장합니다.

### 4-2-3. Java heap space (Maven WAR 빌드 시 메모리 부족)

**증상**: `maven-war-plugin` 실행 중 `Error assembling WAR: ... Java heap space` 또는 `java.lang.OutOfMemoryError: Java heap space` 오류가 발생합니다.

**원인**: Maven이 사용하는 JVM 힙 메모리가 부족합니다. 대형 프로젝트나 멀티 모듈 빌드에서 WAR 조립 시 메모리를 많이 쓰면 발생합니다.

#### 해결: Maven 실행 시 힙 크기 늘리기

Maven이 사용하는 JVM 옵션을 **MAVEN_OPTS** 환경 변수로 지정합니다. Jenkins에서는 파이프라인 `environment` 또는 Build WAR 단계 직전에 설정하면 됩니다.

**방법 A – Jenkinsfile의 environment에 추가 (권장)**

```groovy
pipeline {
  agent any
  tools { maven 'M3' }
  environment {
    MAVEN_OPTS = '-Xmx1024m -Xms256m'   // 최대 1GB 힙. 부족하면 2048m 등으로 증가
    REGISTRY = '172.16.0.194:5000'
    APP_NAME = 'h-cms'
    // ...
  }
  stages {
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp target/*.war app.war'
      }
    }
    // ...
  }
}
```

- `-Xmx1024m`: 최대 힙 1GB. 여전히 부족하면 `-Xmx2048m`, `-Xmx3072m` 등으로 올립니다.
- `-Xms256m`: 초기 힙 (선택). 지정하면 초기 할당 크기가 고정됩니다.

**방법 B – Build WAR 단계에서만 지정**

```groovy
stage('Build WAR') {
  steps {
    sh 'export MAVEN_OPTS="-Xmx2048m -Xms512m" && mvn clean package -DskipTests'
    sh 'cp target/*.war app.war'
  }
}
```

**방법 C – Jenkins Global Tool Configuration**

Manage Jenkins → **Tools** → Maven → 해당 Maven 항목 → **Properties** (또는 **Advanced**)에 다음 추가:

- **Name**: `MAVEN_OPTS`
- **Value**: `-Xmx2048m -Xms512m`

(항목 이름이 "Environment variables" 등으로 되어 있으면 `MAVEN_OPTS=-Xmx2048m` 형태로 넣습니다.)

**참고**: Jenkins 실행 환경(서버 또는 Agent)의 메모리 한도보다 Maven 힙을 너무 크게 주면 OOM이 날 수 있으므로, 사용 가능한 메모리보다 작게 `-Xmx`를 설정하는 것이 좋습니다.

### 4-2-4. 멀티 모듈에서 WAR 파일 경로

**단일 모듈** 프로젝트에서는 Maven 산출물이 루트의 `target/*.war`에 생성됩니다. **멀티 모듈**에서는 WAR를 만드는 서브모듈의 `target/` 아래에 생성됩니다.

예: `humanframe.web/target/jnet.humanframe.web-2.2.1.war` → 워크스페이스 루트 기준으로 `humanframe.web/target/` 안에 WAR가 있으므로, 복사 시 해당 경로를 사용합니다.

| 프로젝트 구조                                    | 복사 명령 예시                                                       |
| ------------------------------------------------ | -------------------------------------------------------------------- |
| 단일 모듈 (루트에 pom + target)                  | `sh 'cp target/*.war app.war'`                                       |
| 멀티 모듈, WAR가 `humanframe.web/target/`에 있음 | `sh 'cp humanframe.web/target/*.war app.war'`                        |
| 서브모듈 경로가 다름                             | `sh 'cp <서브모듈디렉터리>/target/*.war app.war'` (실제 경로로 변경) |

**경로를 모를 때**: 빌드 한 번 실행 후 Console Output에서 `Building war: .../target/xxx.war` 로그를 확인하거나, 아래처럼 찾아서 복사할 수 있습니다.

```groovy
sh 'cp $(find . -name "*.war" -path "*/target/*" | head -1) app.war'
```

`app.war`는 Dockerfile이 같은 디렉터리에서 `COPY app.war` 하므로, **워크스페이스 루트**에 두면 됩니다. 위 `cp` 명령은 모두 워크스페이스 루트에서 실행된다고 가정합니다.

### 4-2-5. Insecure Registry (HTTP 5000)

`https://` 없이 사용하는 레지스트리인 경우, Docker 데몬의 `insecure-registries`에 해당 주소를 넣어야 합니다. Jenkins Agent가 사용하는 Docker 호스트에서:

```bash
# /etc/docker/daemon.json
{
  "insecure-registries": ["172.16.0.194:5000"]
}
```

재시작: `sudo systemctl restart docker`

### 4-3. (선택) Kaniko로 이미지 빌드·푸시

Docker를 사용할 수 없는 **Kubernetes 에이전트** 등에서만 사용하는 방식입니다. **04번처럼 Linux에 Jenkins를 직접 설치하고 같은 서버에 Docker가 있다면** 위 **4단계 기본 예시**(`agent any` +
`docker.build()`)를 사용하는 것이 더 단순합니다. Docker 소켓을 쓸 수 없을 때만 Kaniko 단계로 대체할 수 있습니다.

#### Kaniko 사용 시 필수: Kubernetes Pod Template

`container('kaniko')`를 쓰려면 파이프라인이 **Kubernetes Pod 에이전트** 위에서 돌아야 합니다. 따라서 **agent를 `agent any`가 아니라 Kubernetes podTemplate을 쓰도록** 변경해야 합니다.

**전체 Jenkinsfile 예시 (Kaniko + Maven, Kubernetes Agent)** Registry 주소·앱명·Credentials ID는 환경에 맞게 변경하세요. Workspace Cleanup 플러그인이 있으면 `post { always { cleanWs() } }` 사용
가능합니다.

```groovy
pipeline {
  agent {
    kubernetes {
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: jnlp
    image: jenkins/inbound-agent:4.11-1
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command: ["/busybox/cat"]
    tty: true
"""
    }
  }
  tools {
    maven 'M3'
  }
  environment {
    MAVEN_OPTS = '-Xmx2048m -Xms256m'
    REGISTRY = '172.16.0.194:5000'
    APP_NAME = 'h-cms'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp humanframe.web/target/*.war app.war'
      }
    }
    stage('Docker Build & Push (Kaniko)') {
      steps {
        container('kaniko') {
          sh """
            /kaniko/executor \
              --context ${env.WORKSPACE} \
              --dockerfile ${env.WORKSPACE}/Dockerfile \
              --destination ${env.IMAGE} \
              --destination ${env.IMAGE_LATEST} \
              --insecure \
              --skip-tls-verify
          """
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
```

**변경 포인트 요약**

| 항목                   | 변경 내용                                                                                                     |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| **agent**              | `agent any` → `agent { kubernetes { ... } }` (Pod에 `jnlp` + `kaniko` 컨테이너 정의)                          |
| **Kaniko 경로**        | `\${WORKSPACE}` → `${env.WORKSPACE}` (Groovy에서 경로 확장 후 컨테이너에 전달, 워크스페이스 공유 경로 동일)   |
| **Kaniko 이미지 주소** | `--destination ${IMAGE}` → `--destination ${env.IMAGE}` (컨테이너 내부에서 env로 전달되므로 `env.` 사용 권장) |
| **post**               | `cleanWs()` 유지 (Workspace Cleanup 플러그인 설치 시 Kubernetes 에이전트에서도 동작)                          |

**Registry 인증이 필요한 경우** Private Registry에 push 시 인증이 필요하면, Kaniko가 읽는 `/kaniko/.docker/config.json`을 Pod에 마운트해야 합니다. Kubernetes Secret으로 docker config를 만든 뒤 Pod
Template의 `kaniko` 컨테이너에 volumeMount로 넣거나, Kaniko 문서의 인증 방식을 따릅니다.

**기존 단계만 참고할 때 (agent는 이미 Kubernetes로 설정된 경우)**

```groovy
stage('Docker Build & Push (Kaniko)') {
  steps {
    container('kaniko') {
      sh """
        /kaniko/executor \
          --context ${env.WORKSPACE} \
          --dockerfile ${env.WORKSPACE}/Dockerfile \
          --destination ${IMAGE} \
          --destination ${IMAGE_LATEST} \
          --insecure \
          --skip-tls-verify
      """
    }
  }
}
```

---

## 5단계: Kubernetes 배포 단계 연동

Jenkins 파이프라인에서 이미지 푸시까지 성공한 뒤, 같은 Job에 **Kubernetes 배포 단계**를 추가합니다.

### 5-1. 배포 매니페스트 위치

- **옵션 A**: 배포 매니페스트를 **Git 저장소**에 포함 (예: `k8s/deployment.yaml`)
- **옵션 B**: Jenkins가 **고정 경로**의 매니페스트 사용 (예: Jenkins Agent 내부 또는 공유 스토리지)

옵션 A를 권장합니다. 저장소에 있으면 버전 관리와 배포 버전 일치가 쉽습니다.

### 5-2. deployment.yaml에서 이미지 주소 치환

07번 5단계의 Deployment에서 `image`를 Jenkins에서 푸시한 이미지로 맞춰야 합니다. 빌드 번호를 태그로 쓰면 롤백이 쉽습니다.

- `image: '<REGISTRY_IP>:5000/h-cms:latest'` 또는
- `image: '<REGISTRY_IP>:5000/h-cms:<BUILD_NUMBER>'`

Jenkinsfile에서 `sed`로 치환한 뒤 `kubectl apply`하는 예시는 아래와 같습니다.

### 5-3. Jenkinsfile에 배포 단계 추가

환경 변수에 `REGISTRY`, `APP_NAME`, `IMAGE`가 이미 있다고 가정합니다.

```groovy
environment {
  REGISTRY = '172.16.0.194:5000'
  APP_NAME = 'h-cms'
  IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
  IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  NAMESPACE = 'dev'
}
```

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
          -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
          k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

또는 **latest**만 쓰는 경우:

```groovy
stage('Deploy to Kubernetes') {
  steps {
    sh """
      export REGISTRY_HOST="${REGISTRY.split(':')[0]}"
      sed -e "s|<REGISTRY_IP>|\${REGISTRY_HOST}|g" k8s/deployment.yaml | kubectl apply -f -
    """
  }
}
```

- `k8s/deployment.yaml`: 07번 5단계의 Deployment·Service 매니페스트. `image`에 `<REGISTRY_IP>`, 필요 시 `:latest` 또는 `:<BUILD_NUMBER>` 패턴을 넣어 두고, 위 `sed`로 치환합니다.
- Jenkins Agent(또는 Jenkins 실행 환경)에 `kubectl`이 설치되어 있고, 클러스터 접근이 가능해야 합니다. Kubernetes Cloud를 쓰는 경우 Agent Pod에 `kubectl` 이미지를 쓰거나, 서비스 계정으로 인증되도록
  설정합니다.

### 5-4. 네임스페이스·imagePullSecrets 사전 준비

07번 4단계처럼 배포 전에 한 번 실행해 두세요.

```bash
kubectl create namespace dev
kubectl create secret docker-registry registry-secret \
  --docker-server=172.16.0.194:5000 \
  --docker-username=admin \
  --docker-password=admin123 \
  -n dev
```

Jenkins에서 네임스페이스·시크릿을 만들고 싶다면, 배포 단계 이전에 `kubectl create namespace ...`, `kubectl create secret docker-registry ...` 단계를 Jenkinsfile에 넣을 수 있습니다 (이미 있으면 실패할
수 있으므로 `|| true` 또는 스크립트로 존재 여부 확인 후 생성).

### 5-5. 전체 Jenkinsfile 예시 (WAR 빌드 → 이미지 푸시 → 배포)

```groovy
pipeline {
  agent any
  tools {
    maven 'M3'   // Global Tool Configuration에서 등록한 Maven 이름
  }
  environment {
    REGISTRY = '172.16.0.194:5000'
    APP_NAME = 'h-cms'
    NAMESPACE = 'dev'
    IMAGE = "${REGISTRY}/${APP_NAME}:${env.BUILD_NUMBER}"
    IMAGE_LATEST = "${REGISTRY}/${APP_NAME}:latest"
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Build WAR') {
      steps {
        sh 'mvn clean package -DskipTests'
        sh 'cp humanframe.web/target/*.war app.war'   // 멀티 모듈: WAR 나오는 경로로 변경 (4-2-4 참고)
      }
    }
    stage('Docker Build & Push') {
      steps {
        script {
          docker.build("${IMAGE}")
          docker.withRegistry("https://${REGISTRY}", 'registry-credentials') {
            docker.image("${IMAGE}").push()
            docker.image("${IMAGE}").push('latest')
          }
        }
      }
    }
    stage('Deploy to Kubernetes') {
      steps {
        sh """
          sed -e 's|<REGISTRY_IP>|${REGISTRY.split(':')[0]}|g' \
              -e 's|:5000/${APP_NAME}:latest|:5000/${APP_NAME}:${env.BUILD_NUMBER}|g' \
              k8s/deployment.yaml | kubectl apply -f -
        """
      }
    }
  }
  post {
    always { deleteDir() }   // 워크스페이스 정리 (Kubernetes 노드 불필요)
  }
}
```

저장소 구조 예:

```
프로젝트 루트/
  Jenkinsfile
  Dockerfile
  pom.xml
  src/...
  k8s/
    deployment.yaml   # 07번 5단계 내용, image에 <REGISTRY_IP> 등 치환 가능한 값 사용
```

---

## 6단계: 배포 확인 및 트러블슈팅

### 6-1. 파이프라인 실행 후 확인

1. **Console Output**에서 Checkout → Build WAR → Docker Build & Push → Deploy to Kubernetes 순서로 성공 여부 확인
2. **Registry에 이미지 존재 여부**:

```bash
curl -s -u admin:admin123 "http://172.16.0.194:5000/v2/h-cms/tags/list"
```

3. **Pod·Service 상태**:

```bash
kubectl get pods -n dev -l app=h-cms
kubectl get svc -n dev h-cms
```

4. **애플리케이션 접근** (07번 6단계 참고):

```bash
kubectl port-forward -n dev svc/h-cms 8080:80
# 브라우저: http://localhost:8080
```

### 6-2. 자주 나오는 오류

| 현상                                                 | 원인                                                                                                       | 조치                                                                                                                                                                                     |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mvn: not found`                                     | Jenkins 이미지에 Maven 미포함                                                                              | [4-2-1](#4-2-1-mvn-not-found-해결-maven-사용-방법): Global Tool Configuration에서 Maven 자동 설치 후 `tools { maven 'M3' }` 사용, 또는 Docker로 Maven 컨테이너 사용                      |
| `maven-default-http-blocker`, HTTP 저장소 차단       | Maven 3.8.1+ 기본 정책으로 HTTP 저장소 차단                                                                | [4-2-2](#4-2-2-http-저장소-차단-maven-default-http-blocker): Maven 3.6.3 사용 또는 settings.xml에 `maven-default-http-blocker`를 `blocked=false`로 덮어쓰기                              |
| `Java heap space`, `Error assembling WAR`            | Maven JVM 힙 부족                                                                                          | [4-2-3](#4-2-3-java-heap-space-maven-war-빌드-시-메모리-부족): Jenkinsfile `environment`에 `MAVEN_OPTS=-Xmx1024m` 또는 `-Xmx2048m` 설정                                                  |
| `Node is not a Kubernetes node`                      | post/단계가 Kubernetes 전용 step(container, podTemplate 등)을 사용하거나 Kubernetes 에이전트 전제로 동작함 | 문서 기본 예시는 **일반 노드**(`agent any`)용. `cleanWs` → `deleteDir()` 로 변경, Kubernetes용 `container`/`podTemplate` 제거. Job이 **Docker 설치된 일반 에이전트**에서 실행되도록 설정 |
| `docker.build` 실패                                  | Agent에 Docker 없음 또는 Docker 소켓 미연결                                                                | Docker 사용 가능한 Agent 사용 또는 Kaniko로 전환                                                                                                                                         |
| `denied: requested access to the resource is denied` | Registry 인증 실패                                                                                         | Credentials ID·Username/Password 확인, [4-2-5](#4-2-5-insecure-registry-http-5000) insecure-registries 확인                                                                              |
| `ImagePullBackOff`                                   | K8s에서 이미지 pull 실패                                                                                   | imagePullSecrets·이미지 주소·레지스트리 접근 가능 여부 확인                                                                                                                              |
| `kubectl: command not found`                         | Agent에 kubectl 미설치                                                                                     | Agent 이미지에 kubectl 포함 또는 설치 단계 추가                                                                                                                                          |
| `Unable to connect to the server`                    | kubectl 클러스터 미연결                                                                                    | KUBECONFIG 또는 서비스 계정 권한 확인                                                                                                                                                    |

### 6-3. 롤백

특정 빌드 번호로 되돌리려면:

```bash
# deployment.yaml의 image를 이전 BUILD_NUMBER로 수정 후
kubectl apply -f k8s/deployment.yaml
# 또는
kubectl set image deployment/h-cms hcms=172.16.0.194:5000/h-cms:<이전빌드번호> -n dev
kubectl rollout status deployment/h-cms -n dev
```

---

## 요약

| 단계 | 내용                                                                           |
| ---- | ------------------------------------------------------------------------------ |
| 1    | Jenkins 설치 (04번: Linux 직접 설치, 접속 http://172.16.0.194:8080)              |
| 2    | 플러그인 (Pipeline, Git, Docker Pipeline, Credentials) 및 보안 설정            |
| 3    | Credentials: Registry, Git, (선택) Kubernetes                                  |
| 4    | Pipeline Job (SCM + Jenkinsfile), Dockerfile·Jenkinsfile 저장소 배치           |
| 5    | Jenkinsfile에 Deploy 단계 추가 (sed + kubectl apply), k8s/deployment.yaml 준비 |
| 6    | Console·Registry·kubectl·브라우저로 배포 결과 확인                             |

- **기존 기능 유지**: 01·02·04·07번 문서의 구성(클러스터, Registry, Jenkins, Tomcat 배포)은 그대로 두고, Jenkins만 WAR 빌드 → 이미지 푸시 → Kubernetes 배포까지 연결한 형태입니다.
- **확장**: 05번 Argo CD와 연동하려면, Jenkins는 이미지 푸시만 하고 이미지 태그는 Git(Helm/Kustomize 등)에 반영한 뒤 Argo CD가 배포하도록 구성할 수 있습니다.
